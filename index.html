<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‹±æ–‡å­¸ç¿’éŠæˆ²æ¨‚åœ’</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* åŸºç¤è¨­ç½®èˆ‡å¯æ„›é…è‰² */
        .game-font { font-family: 'Inter', sans-serif; }
        .shadow-cute { box-shadow: 0 4px 0 0 #D1A3A3; }
        .key-btn { height: 50px; transition: all 0.1s; text-transform: none; }
        .key-btn:active { box-shadow: 0 2px 0 0 #D1A3A3; transform: translateY(2px); }

        /* --- æ ¸å¿ƒ: è¨Šæ¯æç¤ºæ¡† (å³ä¸Šè§’å°æç¤º) --- */
        
        /* Game 1: è©å½™å°å°ç¢° (Dinosaur/Card Flip) */
        .g1-card-item {
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            height: 100%;
            cursor: pointer;
            border-radius: 1rem;
            box-shadow: 0 6px 0 0 #D1A3A3;
        }
        .g1-card-item.flipped { transform: rotateY(180deg); }
        .g1-card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 4px solid;
            user-select: none;
        }
        .g1-card-front {
            background-color: #FFC7C7; /* ç²‰è‰²è›‹æ®¼ */
            border-color: #FF8FAB;
            font-size: 2rem;
            color: #8B4513; /* æ£•è‰²æé¾ç´‹ç† */
        }
        .g1-card-back {
            background-color: #BDE0FE; /* è—è‰²å…§å®¹é¢ */
            border-color: #89CFF0;
            transform: rotateY(180deg);
            flex-direction: column;
            padding: 10px;
        }
        .g1-card-matched {
            background-color: #90EE90 !important;
            border-color: #3CB371 !important;
            box-shadow: none !important;
            cursor: default;
        }

        /* Game 2: æ‹¼è®€æ©Ÿå™¨äºº (Robot) */
        .g2-letter-block {
            transition: all 0.15s;
            box-shadow: 0 3px 0 0 #4B5563; /* æ©Ÿå™¨äººæ·±ç° */
        }
        .g2-letter-block:active {
            box-shadow: 0 1px 0 0 #4B5563;
            transform: translateY(2px);
        }
        .g2-slot {
            min-width: 50px;
            height: 60px;
            border: 4px dashed #93C5FD;
            border-radius: 8px;
            background-color: #EFF6FF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Game 3: å–®å­—å°‹å¯¶è¶£ (Word Search) */
        .g3-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            width: 100%;
            max-width: 450px;
            margin: 0 auto;
            background-color: #FFFFFF; /* ç™½è‰²èƒŒæ™¯ */
            padding: 10px;
            border-radius: 0.5rem;
            border: 4px solid #4299E1; /* Blue 500 */
        }
        .g3-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            user-select: none;
            border: 1px solid #E2E8F0;
            transition: all 0.2s;
            color: #2D3748;
        }
        .g3-cell:hover {
            background-color: #EBF8FF;
        }
        .g3-cell.selected {
            background-color: #FBD38D; /* Orange 200 */
            color: #C05621;
            border-color: #F6AD55;
        }
        .g3-cell.found {
            background-color: #68D391; /* Green 400 */
            color: white;
            border-color: #48BB78;
            animation: pulse 0.5s;
        }
        .g3-word-item {
            transition: all 0.3s;
        }
        .g3-word-item.found {
            text-decoration: line-through;
            color: #A0AEC0; /* Gray 500 */
            background-color: #EDF2F7;
        }

        /* Game 4: æ–‡æ³•åœè»Šå ´ (Car/Parking Lot) - åœè»Šå ´å„ªåŒ– */
        /* åœè»Šæ ¼æŒ‰éˆ• */
        .g4-option-btn {
            background-color: #9CA3AF; /* ç°è‰²æ°´æ³¥åœè»Šæ ¼ */
            color: #FFFFFF; /* ç™½è‰²å–®å­— */
            border: 3px solid #6B7280;
            font-size: 1.25rem;
            transition: all 0.2s;
            box-shadow: 0 4px 0 0 #4B5563; /* æ·±ç°é™°å½± */
        }
        .g4-option-btn:active {
            box-shadow: 0 2px 0 0 #4B5563;
            transform: translateY(2px);
        }
        /* å¥å­å€åŸŸ - æ¨¡æ“¬è»Šé“/è»Šèº« */
        .g4-sentence-box {
            background-color: #FEF9C3; /* æ·ºé»ƒè‰²è»Šèº« */
            border: 4px solid #FCD34D;
            border-radius: 20px 20px 10px 10px; /* æ¨¡æ“¬è»Šé ‚çš„åœ“å¼§ */
            padding: 30px 20px 20px;
            box-shadow: 0 8px 0 0 #F59E0B;
            position: relative;
            margin-top: 15px; /* ç•™å‡ºè»Šç‡ˆç©ºé–“ */
        }
        /* æ¨¡æ“¬è»Šç‡ˆå’Œæ¨™é¡Œ */
        .g4-sentence-box::before {
            content: "ğŸš—"; /* å¡é€šè»Šåœ–ç¤º */
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2.5rem;
            line-height: 1;
        }
        /* æ¨¡æ“¬è¼ªèƒ */
        .g4-sentence-box::after {
            content: "";
            position: absolute;
            bottom: -15px;
            left: 10%;
            right: 10%;
            height: 10px;
            background-image: radial-gradient(circle at 10px 5px, #4B5563 8px, transparent 8px),
                              radial-gradient(circle at calc(100% - 10px) 5px, #4B5563 8px, transparent 8px);
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .g4-sentence-part {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1F2937; /* æ·±ç°å­—é«” */
        }
        /* å¡«ç©ºå€ - æ¨¡æ“¬ç©ºç™½è»Šä½ */
        .g4-blank {
            min-width: 120px;
            height: 40px;
            background-color: #E5E7EB; /* æ·ºç°åº•è‰² */
            border: 3px dashed #6B7280;
            border-radius: 6px;
            display: inline-block;
            line-height: 40px;
            text-align: center;
            color: #374151;
            font-weight: bold;
            margin: 0 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        .g4-blank-filled {
            background-color: #3CB371; /* ç¶ è‰²å¡«å…¥ */
            color: white;
            border: 3px solid #3CB371;
            padding: 0 10px; /* ç¢ºä¿å…§å®¹ä¸æœƒé ‚åˆ°é‚Šç·£ */
        }

        /* Game 6: å°‹å¯¶ (Treasure Map) */
        .g6-question-box {
            background-color: #FEF3C7;
            border: 4px solid #FBBF24;
            box-shadow: 0 8px 0 0 #D97706;
            padding: 20px;
            border-radius: 15px;
        }

        /* Game 7: æ¯”è¼ƒç´š (Balance Scale) - é»ƒ/æ©˜è‰²èª¿ */
        .g7-header {
            background-color: #F97316; /* Orange 600 */
            border-color: #9A3412; /* Darker Orange */
        }
        .g7-image-box {
            min-height: 150px;
            background-color: #FFF;
            border: 4px solid #FCD34D; /* Yellow */
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        .g7-question-area {
            background-color: #FEF9C3;
            border: 2px solid #FBBF24;
        }
        .g7-option-btn-style {
            background-color: #FFC7C7; /* Primary Pink */
            color: #8B4513; /* Brown text */
            box-shadow: 0 3px 0 0 #D1A3A3;
        }
        .g7-option-btn-style:hover {
             background-color: #FF8FAB; 
        }
        
        /* Admin Edit Styles */
        .admin-input {
            width: 100%;
            padding: 4px 8px;
            margin-bottom: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .shake { animation: shake 0.5s; }
    </style>
</head>
<body class="bg-background-light min-h-screen game-font flex flex-col items-center p-4">

    <!-- è¨Šæ¯æç¤ºæ¡† (é ‚éƒ¨å³å´ - å·²ä¿®æ­£ç‚ºéä¸­å¤®æ”¾å¤§) -->
    <div id="message-box" class="fixed top-4 right-4 z-50 opacity-0 transition-all duration-300 transform translate-y-[-20px] pointer-events-none max-w-sm">
        <div id="message-content-wrapper" class="p-3 rounded-lg shadow-xl">
            <p id="message-content"></p>
        </div>
    </div>

    <!-- é ‚éƒ¨æ¨™é¡Œèˆ‡å°èˆª -->
    <header class="w-full max-w-6xl text-center mb-4 p-4 bg-primary-pink rounded-2xl shadow-lg border-b-4 border-pink-400">
        <h1 class="text-3xl md:text-5xl font-extrabold text-white tracking-wider">
            <!-- å¯æ„›å°è±¬åœ–ç¤º (SVG) -->
            <svg class="h-10 w-10 md:h-12 md:w-12 inline-block mr-3 transform -translate-y-1" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM15 9C15.8284 9 16.5 8.32843 16.5 = 7.5C16.5 6.67157 15.8284 6 15 6C14.1716 6 13.5 6.67157 13.5 7.5C13.5 8.32843 14.1716 9 15 9ZM9 9C9.82843 9 10.5 8.32843 10.5 7.5C10.5 6.67157 9.82843 6 9 6C8.17157 6 7.5 6.67157 7.5 7.5C7.5 8.32843 8.1716 9 9 9Z" fill="#FF8FAB"/><path d="M12 17C14.2091 17 16 15.2091 16 13C16 10.7909 14.2091 9 12 9C9.79086 9 8 10.7909 8 13C8 15.2091 9.79086 17 12 17Z" fill="#F0B5C2"/><circle cx="11" cy="13" r="1" fill="#FF8FAB"/><circle cx="13" cy="13" r="1" fill="#FF8FAB"/></svg>
            è‹±æ–‡å­¸ç¿’éŠæˆ²æ¨‚åœ’
        
        </h1>
    </header>

    <!-- å°èˆªåˆ— -->
    <nav class="w-full max-w-6xl mb-6">
        <div class="grid grid-cols-4 gap-2 md:gap-4 justify-center" id="game-nav">
            <button data-game="game1" class="tab-btn">ğŸ¦– è©å½™å°å°ç¢°</button>
            <button data-game="game2" class="tab-btn">ğŸ¤– æ‹¼è®€æ©Ÿå™¨äºº</button>
            <button data-game="game3" class="tab-btn">ğŸ” å–®å­—å°‹å¯¶è¶£</button>
            <button data-game="game4" class="tab-btn">ğŸš— æ–‡æ³•åœè»Šå ´</button>
            <button data-game="game5" class="tab-btn">ğŸ¤¥ èª°èªªè¬Šäº†?</button>
            <button data-game="game6" class="tab-btn">ğŸ—ºï¸ å°‹å¯¶å•ç­”</button>
            <button data-game="game7" class="tab-btn">âš–ï¸ æ¯”è¼ƒç´š</button>
            <button data-game="admin" class="tab-btn">âš™ï¸ å¾Œå°</button>
        </div>
    </nav>

    <!-- ä¸»å…§å®¹å€ -->
    <main id="game-content" class="w-full max-w-6xl bg-white p-4 md:p-8 rounded-2xl shadow-xl border-4 border-secondary-blue flex flex-col space-y-6 min-h-[600px]">
        <div class="flex justify-center items-center h-full">
            <p class="text-xl text-gray-500">æ‡‰ç”¨ç¨‹å¼è¼‰å…¥ä¸­...</p>
        </div>
    </main>
    
    <script>
        // --- å…¨åŸŸè¨­å®šèˆ‡å·¥å…· ---
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-pink': '#FFC7C7',      
                        'secondary-blue': '#BDE0FE',    
                        'accent-yellow': '#FFEC99',     
                        'background-light': '#F8F8F8',  
                        'keyboard-bg': '#FFF5D6',       
                    },
                    boxShadow: {
                        'cute': '0 4px 0 0 #D1A3A3',    
                    }
                }
            }
        }
        
        const ALPHABET = 'abcdefghijklmnopqrstuvwxyz'.split('');
        const LOCAL_STORAGE_KEY = 'GAMES_CUSTOM_DATA_V6'; 
        // ä¿®æ­£ï¼šæ‰€æœ‰å•ç­”/æ‹¼åœ–éŠæˆ²éƒ½æœ€å¤§ 10 é¡Œ (G1 ç„¡é¡Œæ•¸)
        const MAX_QUESTIONS = { g2: 10, g3: 10, g4: 10, g5: 10, g6: 10, g7: 10 }; 

        let currentGame = 'game1'; 
        let localData = {}; 
        
        let selectedWordIds = new Set();
        let editingItemId = null; 
        
        // **ä¿®æ­£ï¼šé€šç”¨è©å½™åº«å…¨å°å¯«åŒ–**
        const ALL_VERBS = ['jump', 'run', 'walk', 'swim', 'sleep', 'read', 'dance', 'sing', 'write', 'talk', 'eat', 'drink'];
        const ALL_ADJECTIVES = ['tall', 'short', 'fast', 'slow', 'happy', 'sad', 'big', 'small', 'old', 'new', 'bright', 'clean', 'beautiful', 'expensive']; 
        const GENERAL_GRAMMAR = ['is', 'am', 'are', 'was', 'were', 'do', 'does', 'did', 'has', 'have', 'had', 'in', 'on', 'at', 'to', 'for', 'of', 'much', 'many', 'how'];
        
        // **æ–°å¢**ï¼šä¸­æ–‡é è¨­æç¤ºè©æ˜ å°„è¡¨
        const DEFAULT_HINTS = {
            'is': 'æ˜¯', 'am': 'æ˜¯', 'are': 'æ˜¯', 'was': 'éå»å¼(æ˜¯)', 'were': 'éå»å¼(æ˜¯)',
            'do': 'åŠ©å‹•è©/ç–‘å•è©', 'does': 'åŠ©å‹•è©/ç–‘å•è©', 'did': 'éå»å¼(åŠ©å‹•è©)',
            'has': 'æ“æœ‰/å®Œæˆå¼', 'have': 'æ“æœ‰/å®Œæˆå¼', 'had': 'éå»å¼(æ“æœ‰)',
            'in': 'åœ¨...è£¡é¢', 'on': 'åœ¨...ä¸Šé¢', 'at': 'åœ¨...ä½ç½®', 'to': 'åˆ°', 'for': 'ç‚ºäº†', 'of': 'çš„',
            'drinks': 'å–', 'playing': 'ç©',
            'big': 'å¤§', 'small': 'å°', 'beautiful': 'ç¾éº—', 'tall': 'é«˜', 'short': 'çŸ®/çŸ­',
            'faster': 'æ›´å¿«', 'taller': 'æ›´é«˜', 'smaller': 'æ›´å°',
            'better': 'æ›´å¥½', 'worse': 'æ›´ç³Ÿ', 'more beautiful': 'æ›´ç¾éº—'
        };

        // --- G7 è¼”åŠ©å·¥å…·ï¼šåç¾©è©æ˜ å°„è¡¨ (Antonym Map) ---
        const ANTONYM_MAP = {
            'TALL': 'SHORT', 'SHORT': 'TALL',
            'BIG': 'SMALL', 'SMALL': 'BIG',
            'FAST': 'SLOW', 'SLOW': 'FAST',
            'HAPPY': 'SAD', 'SAD': 'HAPPY',
            'LONG': 'SHORT', 'OLD': 'NEW', 'NEW': 'OLD',
            'GOOD': 'BETTER', 'BAD': 'WORSE'
        };

        // --- é è¨­å–®å­—åº« (èˆ‡æ–°éŠæˆ²çµæ§‹åŒ¹é…) ---
        const DEFAULT_WORDS = {
            g1_words: [
                { id: 'w1', word: 'CAKE', emoji: 'ğŸ‚' }, { id: 'w2', word: 'PIZZA', emoji: 'ğŸ•' },
                { id: 'w3', word: 'CAR', emoji: 'ğŸš—' }, { id: 'w4', word: 'BIRD', emoji: 'ğŸ¦' },
            ],
            g2_words: ['ROBOT', 'COMPUTER', 'SPACESHIP', 'BUTTON', 'MEMORY', 'KEYBOARD', 'MONITOR', 'MOUSE', 'CABLE', 'PRINTER'],
            // G3 æ”¹ç‚ºé€šç”¨å–®å­—å°‹å¯¶ (ä»»ä½•è©æ€§)
            g3_words: [
                { id: 'a1', verb: 'JUMP' }, { id: 'a2', verb: 'APPLE' },
                { id: 'a3', verb: 'SCHOOL' }, { id: 'a4', verb: 'READ' },
                { id: 'a5', verb: 'HAPPY' },
            ],
            g4_grammar: [
                { id: 'g1', sentence: 'I __ playing my toys.', answer: 'am', hint: 'æ˜¯/æ­£åœ¨' }, 
                { id: 'g2', sentence: 'She __ a doctor.', answer: 'is', hint: 'æ˜¯' },
                { id: 'g3', sentence: 'The cat is __ the box.', answer: 'in', hint: 'åœ¨...è£¡é¢' },
                { id: 'g4', sentence: 'They __ happy.', answer: 'are', hint: 'æ˜¯' },
                { id: 'g5', sentence: 'He __ milk every day.', answer: 'drinks', hint: 'å–' },
                { id: 'g6', sentence: '__ you have Math today?', answer: 'Do', hint: 'åŠ©å‹•è©/ç–‘å•è©' },
                { id: 'g7', sentence: 'Where __ you going?', answer: 'are', hint: 'æ˜¯' }, 
            ],
            g5_true_false: [
                { id: 't1', statement: 'This is a small dog.', imageUrl: 'https://placehold.co/150x120/8254A9/FFFFFF?text=BIG+DOG', answer: false },
                { id: 't2', statement: 'The apple is red.', imageUrl: 'https://placehold.co/150x120/FF6347/FFFFFF?text=RED+APPLE', answer: true },
                { id: 't3', statement: 'A bird can swim.', imageUrl: 'https://placehold.co/150x120/4682B4/FFFFFF?text=BLUE+BIRD', answer: false },
            ],
            g6_qa_match: [
                { id: 'q1', question: 'How are you?', answer: "I'M FINE, THANK YOU." },
                { id: 'q2', question: 'What is your name?', answer: "MY NAME IS TOM." },
                { id: 'q3', question: 'Where is the library?', answer: "IT IS NEXT TO THE BANK." },
            ],
            g7_comparatives: [
                { id: 'c1', nounA: 'Elephant', nounB: 'Mouse', answer: 'bigger', urlA: 'https://placehold.co/150x120/3CB371/FFFFFF?text=A', urlB: 'https://placehold.co/150x120/FFD700/000000?text=B', hint: 'æ›´å¤§çš„' },
                { id: 'c2', nounA: 'Pencil', nounB: 'Ruler', answer: 'longer', urlA: 'https://placehold.co/150x120/87CEEB/FFFFFF?text=A', urlB: 'https://placehold.co/150x120/FA8072/FFFFFF?text=B', hint: 'æ›´é•·çš„' },
                { id: 'c3', nounA: 'Rose', nounB: 'Daisy', answer: 'more beautiful', urlA: 'https://placehold.co/150x120/FF69B4/FFFFFF?text=A', urlB: 'https://placehold.co/150x120/F0E68C/000000?text=B', hint: 'æ›´ç¾éº—çš„' } 
            ],
        };


        // --- éŠæˆ²ç‹€æ…‹ç®¡ç† ---
        let state = {
            // G1: Match Card
            g1_matchCards: [], g1_flippedCards: [], g1_matchCount: 0, g1_gameStatus: 'ready',
            // G2: Spelling Robot (Quiz mode)
            g2_currentWord: '', g2_shuffledLetters: [], g2_answerSlots: [], g2_gameStatus: 'ready',
            // G3 Word Search
            g3_grid: [], g3_targetWords: [], g3_foundWords: new Set(), g3_foundCells: new Set(), g3_selectionStart: null, g3_selectedCells: [], g3_gameStatus: 'ready', g3_score: 0,
            
            // Quizzes
            currentQuizSet: [], currentQIndex: 0, score: 0, gameStatus: 'ready', MAX_QUESTIONS_KEY: 'g3',
            
            currentQHasScored: false, 
            currentQHasFailed: false, 
            
            // G4 specific
            g4_displaySentence: '',
            // G6 Treasure
            g6_treasures: 0, 
            // G7 Comparative
            g7_currentQuestion: null,
            g7_inputAnswer: '', // å„²å­˜ G7 çš„è¼¸å…¥ç­”æ¡ˆ
        };

        // --- TTS & Utility (ä¿æŒä¸è®Š) ---
        async function callTTS(text) {
            if (!('speechSynthesis' in window)) {
                console.warn("SpeechSynthesis not supported.");
                return;
            }
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; 
            utterance.rate = 0.9;
            
            await new Promise(resolve => {
                utterance.onend = resolve;
                utterance.onerror = (e) => { console.error("SpeechSynthesis error:", e); resolve(); };
                window.speechSynthesis.speak(utterance);
            });
        }

        // --- ä¿®æ­£å¾Œçš„ä¸­å¤®æ”¾å¤§è¨Šæ¯æç¤ºæ¡† ---
        const MessageBox = {
            show: (message, isError = true) => {
                const box = document.getElementById('message-box');
                const content = document.getElementById('message-content');
                const wrapper = document.getElementById('message-content-wrapper');
                
                // è¨­ç½®å…§å®¹
                content.textContent = message;
                
                // è¨­ç½®é¡è‰²å’Œæ¨£å¼
                const bgColor = isError ? 'bg-red-500' : 'bg-green-500';
                wrapper.classList.remove('bg-red-500', 'bg-green-500'); // æ¸…é™¤èˆŠé¡è‰²
                wrapper.classList.add(bgColor, 'text-white');
                
                // é¡¯ç¤ºè¨Šæ¯ (0.3s transition time defined in HTML class)
                box.classList.remove('opacity-0', 'translate-y-[-20px]');
                box.classList.add('opacity-100', 'translate-y-0');
                
                // éš±è—è¨Šæ¯ (0.5ç§’å¾Œ)
                setTimeout(() => {
                    box.classList.remove('opacity-100', 'translate-y-0');
                    box.classList.add('opacity-0', 'translate-y-[-20px]');
                }, 500); // ä¿®æ­£ç‚º 500ms
            }
        };

        function shuffleArray(array) {
            let temp = [...array];
            for (let i = temp.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [temp[i], temp[j]] = [temp[j], temp[i]];
            }
            return temp;
        }
        
        function formatDisplayWord(word, isSentenceStart = false) {
            if (typeof word !== 'string') return word;
            let displayWord = word.replace(/_/g, ' ');
            const originalWord = displayWord;
            if (displayWord.length === 1 && displayWord.toUpperCase() === 'I') return 'I';
            if (isSentenceStart && displayWord.length > 0) {
                 const firstLetter = displayWord.charAt(0).toUpperCase();
                 const restOfWord = displayWord.slice(1);
                 return firstLetter + restOfWord; 
            }
            return originalWord;
        }

        // --- LocalStorage å­˜å„²åŠŸèƒ½ (çµ±ä¸€ç®¡ç†æ‰€æœ‰éŠæˆ²æ•¸æ“š) ---
        function loadWordsFromLocal() {
            try {
                const stored = localStorage.getItem(LOCAL_STORAGE_KEY);
                const loaded = stored ? JSON.parse(stored) : {};
                localData = JSON.parse(JSON.stringify(DEFAULT_WORDS));
                for (const key in loaded) {
                    if (Array.isArray(loaded[key])) {
                        localData[key] = loaded[key].map(item => {
                            if (typeof item === 'object' && item !== null && !item.id) {
                                return { ...item, id: crypto.randomUUID() };
                            }
                            return item;
                        }).filter(item => item !== null && item !== undefined); 
                    }
                }
            } catch (e) {
                console.error("Error loading words from local storage:", e);
                localData = DEFAULT_WORDS;
            }
        }

        function saveWordsToLocal() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(localData));
            } catch (e) {
                console.error("Error saving words to local storage:", e);
                MessageBox.show("ç„¡æ³•ä¿å­˜å–®å­—åˆ°æ‚¨çš„ç€è¦½å™¨ã€‚", true);
            }
        }

        // --- æ ¸å¿ƒæ‡‰ç”¨ç¨‹å¼æ§åˆ¶ ---
        function setTabActive(gameName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('bg-primary-pink', 'text-white', 'shadow-xl', 'scale-105');
                btn.classList.add('bg-white', 'text-gray-700', 'shadow-md', 'hover:bg-secondary-blue');
            });

            const activeTab = document.querySelector(`.tab-btn[data-game="${gameName}"]`);
            if (activeTab) {
                activeTab.classList.remove('bg-white', 'text-gray-700', 'shadow-md', 'hover:bg-secondary-blue');
                activeTab.classList.add('bg-primary-pink', 'text-white', 'shadow-xl', 'scale-105');
            }
        }

        function changeGame(gameName) {
            currentGame = gameName;
            setTabActive(gameName);
            renderApp();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function renderApp() {
            loadWordsFromLocal(); // æ¯æ¬¡æ¸²æŸ“å‰è¼‰å…¥
            const container = document.getElementById('game-content');
            
            if (!container) {
                console.error("Error: Game content container not found during renderApp.");
                return; 
            }

            switch (currentGame) {
                case 'game1': initGame1(); break;
                case 'game2': initGame2(); break;
                case 'game3': initGame3(); break;
                case 'game4': initGame4(); break;
                case 'game5': initGame5(); break;
                case 'game6': initGame6(); break;
                case 'game7': initGame7(); break; 
                case 'admin': renderWordAdmin(); break;
                default: 
                    container.innerHTML = `<div class="flex justify-center items-center h-full min-h-[500px]"><p class="text-3xl text-gray-500 text-center p-10">è«‹é€éä¸Šæ–¹å°èˆªåˆ—é¸æ“‡ä¸€å€‹éŠæˆ²é–‹å§‹ï¼</p></div>`;
                    break;
            }
        }

        // --- Quiz Game Helper Functions (é©ç”¨æ–¼ G2, G4, G5, G6, G7) ---
        function setupQuiz(dataKey, gameId, maxQOverride = null) {
            const source = localData[dataKey];
            const maxQ = maxQOverride || MAX_QUESTIONS[gameId]; 
            
            if (source.length === 0) { 
                MessageBox.show("è«‹åœ¨å¾Œå°æ–°å¢é¡Œç›®ï¼", true); 
                return false;
            }
            const numQuestions = Math.min(source.length, maxQ);
            state.currentQuizSet = shuffleArray(source).slice(0, numQuestions);
            state.currentQIndex = 0;
            state.score = 0;
            state.gameStatus = 'playing';
            state.MAX_QUESTIONS_KEY = gameId; 
            state.currentQHasScored = false;
            state.currentQHasFailed = false;
            return true;
        }

        function checkQuizEnd(renderFunc) {
            if (state.currentQIndex >= state.currentQuizSet.length) {
                state.gameStatus = 'finished';
                MessageBox.show(`éŠæˆ²çµæŸï¼æ‚¨çš„å¾—åˆ†æ˜¯ ${state.score} / ${state.currentQuizSet.length} ğŸ‰`, false);
                renderFunc();
                return true;
            }
            return false;
        }

        function goToNextQuestion(renderFunc) {
            state.currentQIndex++;
            state.currentQHasScored = false;
            state.currentQHasFailed = false;
            if (!checkQuizEnd(renderFunc)) {
                renderFunc();
            }
        }
        
        // --- Game 1: è©å½™å°å°ç¢° (ğŸ¦–) ---
        function initGame1() {
            const source = localData.g1_words;
            if (source.length === 0) { MessageBox.show("è«‹åœ¨å¾Œå°æ–°å¢è©å½™å°å°ç¢°å–®å­—ï¼", true); return; }

            const limitedSource = shuffleArray(source).slice(0, 4); 
            state.g1_matchCount = 0;
            state.g1_flippedCards = [];
            state.g1_gameStatus = 'playing';

            let cardValues = [];
            limitedSource.forEach((item, index) => {
                const groupId = `match-${item.word}-${index}`;
                cardValues.push({ id: crypto.randomUUID(), type: 'WORD', value: item.word, groupId, matched: false, flipped: false });
                cardValues.push({ id: crypto.randomUUID(), type: 'EMOJI', value: item.emoji, groupId, matched: false, flipped: false });
            });

            state.g1_matchCards = shuffleArray(cardValues);
            renderGame1();
        }

        async function handleCardClickG1(id) {
            const cardIndex = state.g1_matchCards.findIndex(c => c.id === id);
            const card = state.g1_matchCards[cardIndex];

            if (!card || card.matched || card.flipped || state.g1_flippedCards.length === 2) return;

            card.flipped = true;
            state.g1_flippedCards.push(card);
            
            if (state.g1_flippedCards.length === 2) {
                const [card1, card2] = state.g1_flippedCards;
                if (card1.groupId === card2.groupId && card1.type !== card2.type) {
                    card1.matched = true;
                    card2.matched = true;
                    state.g1_matchCount++;
                    state.g1_flippedCards = [];
                    renderGame1();
                    if (state.g1_matchCount === state.g1_matchCards.length / 2) {
                        setTimeout(() => MessageBox.show("å¤ªæ£’äº†ï¼å°å°ç¢°æˆåŠŸï¼ğŸ‰", false), 500);
                        state.g1_gameStatus = 'won';
                    }
                } else {
                    setTimeout(() => {
                        state.g1_matchCards.forEach(c => {
                            if (c.id === card1.id || c.id === card2.id) c.flipped = false;
                        });
                        state.g1_flippedCards = [];
                        renderGame1();
                    }, 1000);
                }
            }
            renderGame1();
        }

        function renderGame1() {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game1') return; 

            const cardsHtml = state.g1_matchCards.map(card => {
                const isMatched = card.matched;
                const isFlipped = card.flipped || isMatched;

                return `
                    <div class="h-28 md:h-36 rounded-xl" onclick="handleCardClickG1('${card.id}')">
                        <div class="g1-card-item ${isFlipped ? 'flipped' : ''} ${isMatched ? 'g1-card-matched' : ''}">
                            <!-- èƒŒé¢ï¼šæé¾è›‹æ®¼ -->
                            <div class="g1-card-face g1-card-front text-6xl">
                                ğŸ¦–
                            </div>
                            <!-- æ­£é¢ï¼šå…§å®¹ -->
                            <div class="g1-card-face g1-card-back">
                                <span class="text-3xl md:text-4xl">${card.type === 'EMOJI' ? card.value : formatDisplayWord(card.value)}</span>
                                ${card.type === 'WORD' ? `<span class="text-sm text-gray-600 mt-1">(word)</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = `
                <section class="w-full bg-secondary-blue p-4 rounded-xl shadow-inner border-b-8 border-blue-600">
                    <h2 class="text-xl md:text-3xl font-bold text-blue-800 mb-4 text-center">ğŸ¦– è©å½™å°å°ç¢° (word/emoji match)</h2>
                    <p class="text-center text-sm mb-4">ç›®æ¨™: é…å°å–®å­—å’Œå°æ‡‰çš„ Emojiã€‚å·²å®Œæˆ ${state.g1_matchCount}/${state.g1_matchCards.length / 2} çµ„ã€‚</p>
                    <div class="grid grid-cols-4 gap-3 md:gap-4 max-w-2xl mx-auto">
                        ${cardsHtml}
                    </div>
                    <div class="text-center mt-6">
                        <button onclick="initGame1()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg">
                            ${state.g1_gameStatus === 'won' ? 'å†ç©ä¸€æ¬¡' : 'é‡æ–°é–‹å§‹'}
                        </button>
                    </div>
                </section>
            `;
        }
        // --- Game 1 End ---

        // --- Game 2: æ‹¼è®€æ©Ÿå™¨äºº (ğŸ¤–) ---
        function initGame2() {
            if (!setupQuiz('g2_words', 'g2')) return;
            state.g2_gameStatus = 'playing';
            loadG2Question();
        }
        
        function loadG2Question() {
            const currentWord = state.currentQuizSet[state.currentQIndex];
            if (!currentWord) return;

            const letters = currentWord.split('');

            state.g2_currentWord = currentWord.toUpperCase();
            state.g2_shuffledLetters = shuffleArray(letters.map(l => ({ id: crypto.randomUUID(), letter: l.toUpperCase() })));
            state.g2_answerSlots = Array(letters.length).fill(null);
            
            renderGame2();
        }


        function handleLetterClickG2(id) {
            if (state.gameStatus !== 'playing') return;

            const letterBlockIndex = state.g2_shuffledLetters.findIndex(l => l && l.id === id);
            const letterBlock = state.g2_shuffledLetters[letterBlockIndex];
            if (!letterBlock) return;

            const targetSlotIndex = state.g2_answerSlots.findIndex(slot => slot === null);
            if (targetSlotIndex !== -1) {
                state.g2_answerSlots[targetSlotIndex] = letterBlock;
                state.g2_shuffledLetters[letterBlockIndex] = null; 

                renderGame2();
                checkCompletionG2();
            }
        }
        
        function handleSlotClickG2(index) {
            if (state.gameStatus !== 'playing') return;

            const letterBlock = state.g2_answerSlots[index];
            if (!letterBlock) return;

            const sourceIndex = state.g2_shuffledLetters.findIndex(slot => slot === null);
            if (sourceIndex !== -1) {
                state.g2_shuffledLetters[sourceIndex] = letterBlock;
            } else {
                 state.g2_shuffledLetters.push(letterBlock);
            }
            
            state.g2_answerSlots[index] = null; 

            renderGame2();
        }

        function checkCompletionG2() {
            if (state.g2_answerSlots.some(slot => slot === null)) return;

            const builtWord = state.g2_answerSlots.map(slot => slot.letter).join('');
            
            if (builtWord === state.g2_currentWord) {
                if (!state.currentQHasFailed && !state.currentQHasScored) {
                    state.score++;
                    state.currentQHasScored = true;
                    MessageBox.show(`æ‹¼å­—æˆåŠŸï¼å–®å­—æ˜¯ ${formatDisplayWord(state.g2_currentWord)}ï¼ğŸ‰ (+1 åˆ†)`, false);
                } else {
                    MessageBox.show(`æ‹¼å­—æˆåŠŸï¼è«‹æº–å‚™ä¸‹ä¸€é¡Œã€‚`, false);
                }
                
                setTimeout(() => {
                    goToNextQuestion(renderGame2);
                    if (state.gameStatus === 'playing') loadG2Question();
                }, 1000);

            } else {
                state.currentQHasFailed = true; 
                const display = document.getElementById('g2-answer-display');
                if (display) {
                    display.classList.add('shake');
                    setTimeout(() => display.classList.remove('shake'), 500);
                }
                MessageBox.show("æ‹¼å­—ä¸æ­£ç¢ºï¼Œè«‹å†è©¦è©¦ï¼", true);
            }
        }


        function renderGame2() {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game2') return; 

            if (state.gameStatus === 'finished') {
                 container.innerHTML = getFinishedScreen('ğŸ¤– æ‹¼è®€æ©Ÿå™¨äºº', state.score, state.currentQuizSet.length, initGame2);
                 return;
            }
            
            const questionNumber = state.currentQIndex + 1;

            const answerSlotsHtml = state.g2_answerSlots.map((slot, index) => {
                const letter = slot ? slot.letter : '';
                return `<div class="g2-slot cursor-pointer" onclick="handleSlotClickG2(${index})">${letter}</div>`;
            }).join('');

            const letterBlocksHtml = state.g2_shuffledLetters.filter(l => l !== null).map(l => `
                <button onclick="handleLetterClickG2('${l.id}')" 
                        class="g2-letter-block bg-accent-yellow hover:bg-yellow-400 text-gray-800 font-bold text-xl py-3 px-4 rounded-xl shadow-cute">
                    ${l.letter}
                </button>
            `).join('');

            container.innerHTML = `
                <section class="w-full bg-gray-700 p-4 rounded-xl shadow-inner border-b-8 border-gray-900">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">ğŸ¤– æ‹¼è®€æ©Ÿå™¨äºº (spelling robot)</h2>
                    <p class="text-center text-sm text-gray-300 mb-4">ç›®æ¨™: é»æ“Šä¸‹æ–¹çš„å­—æ¯ï¼ŒæŒ‰æ­£ç¢ºé †åºæ‹¼å‡ºä½ è½åˆ°çš„å–®å­—ï¼åˆ†æ•¸: ${state.score}/${state.currentQuizSet.length}</p>
                </section>
                
                <div class="flex flex-col items-center p-6 bg-white rounded-xl shadow-md">
                    <h3 class="text-lg font-semibold text-gray-700 mb-3">ç¬¬ ${questionNumber} é¡Œ / å…± ${state.currentQuizSet.length} é¡Œ</h3>
                    <button onclick="callTTS(state.g2_currentWord)" class="text-white bg-blue-500 hover:bg-blue-600 py-3 px-6 rounded-full shadow-cute mb-6 flex items-center">
                        <span class="text-3xl mr-2">ğŸ”Š</span> é»æˆ‘è½å–®å­—
                    </button>
                    
                    <div id="g2-answer-display" class="flex space-x-2 mb-8 p-4 bg-gray-100 rounded-lg shadow-inner">
                        ${answerSlotsHtml}
                    </div>

                    <h3 class="text-lg font-semibold text-gray-700 mb-3">å­—æ¯åº« (é»æ“Šå¡«å…¥)</h3>
                    <div class="flex flex-wrap justify-center gap-2 p-3 bg-keyboard-bg rounded-xl w-full">
                        ${letterBlocksHtml}
                    </div>
                    
                    <div class="text-center mt-6">
                        <button onclick="initGame2()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg">
                            ${state.gameStatus === 'won' ? 'å†ç©ä¸€æ¬¡' : 'æ›å€‹å–®å­—'}
                        </button>
                    </div>
                </div>
            `;
        }
        // --- Game 2 End ---
        
        // --- Game 3: å‹•ä½œæŒ‡ä»¤ (Word Search) ---
        // ç”Ÿæˆ Word Search ç¶²æ ¼
        function generateWordSearchGrid() {
            const grid = Array(10).fill(null).map(() => Array(10).fill(''));
            // å¾ g3_words é¸æœ€å¤š 10 å€‹å–®å­—
            const source = localData.g3_words.map(a => a.verb.toUpperCase()); // ä½¿ç”¨ verb å­—æ®µ
            const targets = shuffleArray(source).slice(0, 10);
            
            // æ“ºæ”¾å–®å­—
            const directions = [[0, 1], [1, 0], [1, 1]];
            const placedWords = [];

            for (const word of targets) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 100) {
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    const startR = Math.floor(Math.random() * 10);
                    const startC = Math.floor(Math.random() * 10);
                    const endR = startR + dir[0] * (word.length - 1);
                    const endC = startC + dir[1] * (word.length - 1);

                    if (endR >= 0 && endR < 10 && endC >= 0 && endC < 10) {
                        let collision = false;
                        for (let i = 0; i < word.length; i++) {
                            const r = startR + dir[0] * i;
                            const c = startC + dir[1] * i;
                            if (grid[r][c] !== '' && grid[r][c] !== word[i]) {
                                collision = true; break;
                            }
                        }
                        if (!collision) {
                            for (let i = 0; i < word.length; i++) {
                                grid[startR + dir[0] * i][startC + dir[1] * i] = word[i];
                            }
                            placedWords.push(word);
                            placed = true;
                        }
                    }
                    attempts++;
                }
            }

            // å¡«æ»¿å‰©é¤˜ç©ºæ ¼
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    if (grid[i][j] === '') {
                        grid[i][j] = ALPHABET[Math.floor(Math.random() * 26)].toUpperCase();
                    }
                }
            }

            state.g3_grid = grid;
            state.g3_targetWords = placedWords;
            state.g3_foundWords = new Set();
            state.g3_foundCells = new Set(); // Reset found cells for color clearing
            state.g3_selectionStart = null;
            state.g3_score = 0; 
        }

        function initGame3() {
            if (localData.g3_words.length === 0) { MessageBox.show("è«‹åœ¨å¾Œå°æ–°å¢å–®å­—ï¼", true); return; }
            generateWordSearchGrid();
            state.g3_gameStatus = 'playing';
            renderGame3();
        }

        function handleGridClickG3(row, col) {
            if (state.g3_gameStatus !== 'playing') return;

            if (!state.g3_selectionStart) {
                state.g3_selectionStart = { r: row, c: col };
            } else {
                checkSelectionG3(state.g3_selectionStart, { r: row, c: col });
                state.g3_selectionStart = null;
            }
            renderGame3();
        }

        function checkSelectionG3(start, end) {
            const dr = end.r - start.r;
            const dc = end.c - start.c;
            const steps = Math.max(Math.abs(dr), Math.abs(dc));
            
            if (steps === 0) return; 

            const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
            const stepC = dc === 0 ? 0 : dc / Math.abs(dc);

            if (start.r + stepR * steps !== end.r || start.c + stepC * steps !== end.c) {
                 MessageBox.show("è«‹é¸æ“‡ç›´ç·šè·¯å¾‘ï¼", true);
                 return;
            }

            let selectedWord = "";
            let pathCells = [];
            for (let i = 0; i <= steps; i++) {
                const r = start.r + stepR * i;
                const c = start.c + stepC * i;
                selectedWord += state.g3_grid[r][c];
                pathCells.push({r, c});
            }

            const reversedWord = selectedWord.split('').reverse().join('');
            let found = null;

            if (state.g3_targetWords.includes(selectedWord) && !state.g3_foundWords.has(selectedWord)) {
                found = selectedWord;
            } else if (state.g3_targetWords.includes(reversedWord) && !state.g3_foundWords.has(reversedWord)) {
                found = reversedWord;
            }

            if (found) {
                state.g3_foundWords.add(found);
                state.g3_score++; 
                if (!state.g3_foundCells) state.g3_foundCells = new Set();
                pathCells.forEach(cell => state.g3_foundCells.add(`${cell.r},${cell.c}`));
                MessageBox.show(`æ‰¾åˆ°å–®å­—ï¼š${found}ï¼ğŸ‰ (+1 åˆ†)`, false);
                
                if (state.g3_foundWords.size === state.g3_targetWords.length) {
                    state.g3_gameStatus = 'won';
                    setTimeout(() => MessageBox.show("æ­å–œï¼æ‰€æœ‰å–®å­—éƒ½æ‰¾åˆ°äº†ï¼", false), 1000);
                }
            } else {
                 if(state.g3_foundWords.has(selectedWord) || state.g3_foundWords.has(reversedWord)) {
                      MessageBox.show("é€™å€‹å–®å­—å·²ç¶“æ‰¾éäº†ã€‚", true);
                 } else {
                      MessageBox.show("ä¸æ˜¯ç›®æ¨™å–®å­—ï¼Œå†è©¦è©¦ï¼", true);
                 }
            }
        }

        function renderGame3() {
            const container = document.getElementById('game-content');
            if (currentGame !== 'game3') return;

            if (state.g3_gameStatus === 'won') {
                 container.innerHTML = getFinishedScreen('ğŸ” å–®å­—å°‹å¯¶è¶£', state.g3_score, state.g3_targetWords.length, initGame3);
                 return;
            }

            let gridHtml = '';
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const char = state.g3_grid[r][c];
                    const isSelected = state.g3_selectionStart && state.g3_selectionStart.r === r && state.g3_selectionStart.c === c;
                    const isFound = state.g3_foundCells && state.g3_foundCells.has(`${r},${c}`);
                    
                    let cellClass = 'g3-cell';
                    if (isSelected) cellClass += ' selected';
                    if (isFound) cellClass += ' found';

                    gridHtml += `<div class="${cellClass}" onclick="handleGridClickG3(${r}, ${c})">${char}</div>`;
                }
            }

            const wordListHtml = state.g3_targetWords.map(word => {
                const isFound = state.g3_foundWords.has(word);
                return `<div class="g3-word-item p-2 bg-white rounded shadow-sm text-center font-bold ${isFound ? 'found bg-gray-200' : 'text-blue-800'}">${word}</div>`;
            }).join('');

            container.innerHTML = `
                <section class="w-full bg-blue-500 p-4 rounded-xl shadow-inner border-b-8 border-blue-800">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">ğŸ” å–®å­—å°‹å¯¶è¶£ (word search fun)</h2>
                    <p class="text-center text-sm text-blue-100">ç›®æ¨™: åœ¨ç¶²æ ¼ä¸­æ‰¾å‡ºå³å´åˆ—å‡ºçš„æ‰€æœ‰å–®å­—ã€‚é»æ“Šå–®å­—çš„é¦–å°¾å­—æ¯ä¾†é¸å–ã€‚</p>
                </section>
                
                <div class="flex flex-col md:flex-row gap-6 p-4 justify-center">
                    <!-- Grid -->
                    <div class="g3-grid shadow-lg">
                        ${gridHtml}
                    </div>

                    <!-- Word List -->
                    <div class="flex-1 bg-keyboard-bg p-4 rounded-xl shadow-md border-4 border-accent-yellow max-w-sm">
                        <h3 class="text-lg font-bold text-gray-700 mb-3 text-center">å°‹æ‰¾å–®å­— (${state.g3_foundWords.size}/${state.g3_targetWords.length})</h3>
                        <div class="grid grid-cols-2 gap-2">
                            ${wordListHtml}
                        </div>
                        <div class="text-center mt-6">
                            <button onclick="initGame3()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg">é‡ç½®éŠæˆ²</button>
                        </div>
                    </div>
                </div>
            `;
        }
        // --- Game 3 End ---

        // --- Game 4: æ–‡æ³•åœè»Šå ´ (ğŸš—) ---
        function initGame4() {
            if (!setupQuiz('g4_grammar', 'g4')) return;
            state.g4_displaySentence = ''; // Reset display sentence
            renderGame4();
        }

        function handleAnswerG4(enteredText) {
            if (state.gameStatus !== 'playing') return;

            const currentQ = state.currentQuizSet[state.currentQIndex];
            
            const normalize = (text) => text.trim().replace(/_/g, ' ').toUpperCase();
            
            if (normalize(enteredText) === normalize(currentQ.answer)) {
                
                if (!state.currentQHasFailed && !state.currentQHasScored) {
                    state.score++;
                    state.currentQHasScored = true;
                    MessageBox.show("ç­”å°äº†ï¼æ±½è»Šå·²åœå…¥æ­£ç¢ºè»Šä½ï¼ğŸš— (+1 åˆ†)", false);
                } else {
                    MessageBox.show("å·²ç­”å°ï¼Œè«‹é»æ“Šä¸‹ä¸€é¡Œã€‚ğŸš—", false);
                }
                
                state.g4_displaySentence = currentQ.answer; 
                renderGame4(true); 

            } else {
                state.currentQHasFailed = true; 
                MessageBox.show(`ç­”éŒ¯äº†ï¼Œè«‹å†è©¦è©¦ï¼`, true);
            }
        }

        function renderGame4(isAnswerFilled = false) {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game4') return; 

            if (state.gameStatus === 'finished') {
                container.innerHTML = getFinishedScreen('ğŸš— æ–‡æ³•åœè»Šå ´', state.score, state.currentQuizSet.length, initGame4);
                return;
            }
            
            const currentQ = state.currentQuizSet[state.currentQIndex];
            const questionNumber = state.currentQIndex + 1;
            
            const isAnswerSentenceStartG4 = currentQ.sentence.trim().startsWith('__');
            
            const sentenceWithPlaceholders = currentQ.sentence;
            const parts = sentenceWithPlaceholders.split('__');
            
            const blankContent = isAnswerFilled 
                ? `<span class="g4-blank g4-blank-filled">${formatDisplayWord(state.g4_displaySentence, isAnswerSentenceStartG4)}</span>` 
                : `<span class="g4-blank">...</span>`;

            let questionTextHtml = '';
            
            for(let i = 0; i < parts.length; i++) {
                const part = parts[i].trim();
                
                if (i === 0) {
                     questionTextHtml += formatDisplayWord(part, true);
                } else {
                     questionTextHtml += blankContent;
                     if (part.length > 0) {
                         questionTextHtml += formatDisplayWord(part, false);
                     }
                }
            }
            
            const hintKey = currentQ.answer.toLowerCase().replace(/_/g, ' '); 
            const hintText = currentQ.hint || DEFAULT_HINTS[hintKey] || hintKey; 

            const answerSectionHtml = isAnswerFilled ? '' : `
                <div class="flex flex-col items-center p-4 w-full max-w-lg">
                    <h3 class="text-xl font-bold text-gray-800 mt-6 mb-4">è«‹å¡«å¯«åœè»Šä½</h3>
                    <p class="text-sm text-gray-500 mb-2">æç¤ºè©: (${hintText})</p>
                    <div class="flex w-full space-x-2">
                        <input type="text" 
                               id="g4-input-answer"
                               value="${state.g4_displaySentence}"
                               oninput="state.g4_displaySentence = this.value;"
                               placeholder="è«‹è¼¸å…¥ç­”æ¡ˆ..."
                               class="flex-grow text-2xl p-3 border-4 border-secondary-blue rounded-xl text-center font-bold focus:border-blue-500"
                               onkeypress="if(event.key === 'Enter') handleAnswerG4(this.value);">
                        <button onclick="handleAnswerG4(document.getElementById('g4-input-answer').value)" 
                                class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-xl shadow-cute text-xl">
                            CHECK âœ…
                        </button>
                    </div>
                </div>
            `;


            container.innerHTML = `
                <section class="w-full bg-gray-400 p-4 rounded-xl shadow-inner border-b-8 border-gray-600">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">ğŸš— æ–‡æ³•åœè»Šå ´ (grammar lot)</h2>
                    <p class="text-center text-sm text-gray-800">ç›®æ¨™: æ ¹æ“šæç¤ºè©å®Œæˆå¥å­ã€‚åˆ†æ•¸: ${state.score}/${state.currentQuizSet.length}</p>
                </section>
                
                <div class="flex flex-col items-center p-6 bg-white rounded-xl shadow-md">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">ç¬¬ ${questionNumber} é¡Œ / å…± ${state.currentQuizSet.length} é¡Œ</h3>

                    <div class="g4-sentence-box w-full max-w-2xl text-center mb-6">
                        <div class="text-sm font-bold text-gray-700 mb-2">è«‹å®Œæˆå¥å­ (è»Šèº«):</div>
                        <div class="g4-sentence-part" id="g4-sentence-display">${questionTextHtml}</div>
                    </div>

                    ${answerSectionHtml}
                    
                    ${isAnswerFilled ? `<button onclick="goToNextQuestion(renderGame4)" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8">ä¸‹ä¸€é¡Œ</button>` : ''}
                    <button onclick="initGame4()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8 ${isAnswerFilled ? 'hidden' : ''}">é‡æ–°é–‹å§‹</button>
                </div>
            `;
            if (!isAnswerFilled) {
                setTimeout(() => {
                    document.getElementById('g4-input-answer')?.focus();
                }, 0);
            }
        }
        // --- Game 4 End ---
        
        // --- Game 5: èª°èªªè¬Šäº†? (ğŸ¤¥) ---
        function initGame5() {
            if (!setupQuiz('g5_true_false', 'g5')) return;
            renderGame5();
        }

        function handleAnswerG5(isTrue) {
            if (state.gameStatus !== 'playing') return;

            const currentQ = state.currentQuizSet[state.currentQIndex];
            const isCorrect = (currentQ.answer === isTrue);
            
            if (isCorrect) {
                // ä¿®æ­£ï¼šç­”å°æ™‚æª¢æŸ¥æ˜¯å¦å·²è¨ˆåˆ†
                if (!state.currentQHasFailed && !state.currentQHasScored) {
                    state.score++;
                    state.currentQHasScored = true;
                    MessageBox.show("åˆ¤æ–·æ­£ç¢ºï¼ä½ æ˜¯å€‹èª å¯¦çš„å­©å­ï¼âœ… (+1 åˆ†)", false);
                } else {
                    MessageBox.show("åˆ¤æ–·æ­£ç¢ºï¼âœ… è«‹æº–å‚™ä¸‹ä¸€é¡Œã€‚", false);
                }

                setTimeout(() => goToNextQuestion(renderGame5), 1000);
            } else {
                // ç­”éŒ¯ï¼Œä¸è¨ˆåˆ†ï¼Œä¸è·³é¡Œ
                state.currentQHasFailed = true; // åªè¦éŒ¯ä¸€æ¬¡ï¼Œå°±ä¸èƒ½åŠ åˆ†
                MessageBox.show(`ç­”éŒ¯äº†ï¼Œè«‹å†è©¦è©¦ï¼`, true);
            }
        }

        function renderGame5() {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game5') return; 

            if (state.gameStatus === 'finished') {
                container.innerHTML = getFinishedScreen('ğŸ¤¥ èª°èªªè¬Šäº†?', state.score, state.currentQuizSet.length, initGame5);
                return;
            }
            
            const currentQ = state.currentQuizSet[state.currentQIndex];
            const questionNumber = state.currentQIndex + 1;

            container.innerHTML = `
                <section class="w-full bg-accent-yellow p-4 rounded-xl shadow-inner border-b-8 border-yellow-600">
                    <h2 class="text-xl md:text-3xl font-bold text-yellow-900 mb-2 text-center">ğŸ¤¥ èª°èªªè¬Šäº†? (True/False quiz)</h2>
                    <p class="text-center text-sm text-yellow-800">ç›®æ¨™: æ ¹æ“šåœ–ç‰‡åˆ¤æ–·æè¿°æ˜¯å¦æ­£ç¢ºã€‚åˆ†æ•¸: ${state.score}/${state.currentQuizSet.length}</p>
                </section>
                
                <div class="flex flex-col items-center p-6 bg-white rounded-xl shadow-md">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">ç¬¬ ${questionNumber} é¡Œ / å…± ${state.currentQuizSet.length} é¡Œ</h3>

                    <div class="mb-6 p-4 border-4 border-primary-pink rounded-xl shadow-lg flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-8 w-full max-w-3xl">
                        <div class="flex-shrink-0">
                            <img src="${currentQ.imageUrl}" alt="Question Image" onerror="this.onerror=null; this.src='https://placehold.co/150x120/CCCCCC/000000?text=No+Image'" class="rounded-lg shadow-md w-32 h-32 md:w-40 md:h-40 object-cover">
                        </div>
                        <div class="flex-grow text-center md:text-left">
                            <h4 class="text-2xl md:text-3xl font-extrabold text-pink-600">${formatDisplayWord(currentQ.statement, true)}</h4>
                            <p class="text-sm text-gray-500 mt-1">ï¼ˆè«‹åˆ¤æ–·é€™å¥è©±æ˜¯å¦æ­£ç¢ºï¼Ÿï¼‰</p>
                        </div>
                    </div>

                    <div class="flex space-x-6 mt-6">
                        <button onclick="handleAnswerG5(true)" class="key-btn bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-10 rounded-full shadow-cute text-2xl">
                            âœ… True
                        </button>
                        <button onclick="handleAnswerG5(false)" class="key-btn bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-10 rounded-full shadow-cute text-2xl">
                            âŒ False
                        </button>
                    </div>

                    <button onclick="initGame5()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8">é‡æ–°é–‹å§‹</button>
                </div>
            `;
        }
        // --- Game 5 End ---

        // --- Game 6: å•ç­”é¸æ“‡é¡Œå°‹å¯¶ (ğŸ—ºï¸) ---
        function initGame6() {
            if (!setupQuiz('g6_qa_match', 'g6')) return;
            state.g6_treasures = 0;
            renderGame6();
        }

        function handleAnswerG6(selectedAnswer) {
            if (state.gameStatus !== 'playing') return;

            const currentQ = state.currentQuizSet[state.currentQIndex];
            
            if (selectedAnswer === currentQ.answer) {
                // ä¿®æ­£ï¼šç­”å°æ™‚æª¢æŸ¥æ˜¯å¦å·²è¨ˆåˆ†
                if (!state.currentQHasFailed && !state.currentQHasScored) {
                    state.score++;
                    state.g6_treasures++; // å°‹å¯¶éŠæˆ²çš„é¡å¤–è¨ˆæ•¸
                    state.currentQHasScored = true;
                    MessageBox.show("ç­”å°äº†ï¼æ‰¾åˆ°äº†ä¸€å€‹å¯¶è—ï¼ğŸ’ (+1 åˆ†)", false);
                } else {
                    MessageBox.show("ç­”å°äº†ï¼è«‹æº–å‚™ä¸‹ä¸€é¡Œã€‚ğŸ’", false);
                }

                setTimeout(() => goToNextQuestion(renderGame6), 1000);
            } else {
                // ç­”éŒ¯ï¼Œä¸è¨ˆåˆ†ï¼Œä¸è·³é¡Œ
                state.currentQHasFailed = true; // åªè¦éŒ¯ä¸€æ¬¡ï¼Œå°±ä¸èƒ½åŠ åˆ†
                MessageBox.show(`ç­”éŒ¯äº†ï¼Œè«‹å†è©¦è©¦ï¼`, true);
            }
        }

        function renderGame6() {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game6') return; 

            if (state.gameStatus === 'finished') {
                container.innerHTML = getFinishedScreen('ğŸ—ºï¸ å•ç­”é¸æ“‡é¡Œå°‹å¯¶', state.score, state.currentQuizSet.length, initGame6);
                return;
            }
            
            const currentQ = state.currentQuizSet[state.currentQIndex];
            const questionNumber = state.currentQIndex + 1;
            
            // --- G6 ç°¡åŒ–é‚è¼¯ï¼šå‹•æ…‹ç”Ÿæˆå¹²æ“¾é¸é … (å¿…é ˆæ˜¯ 4 å€‹) ---
            const correctAnswer = currentQ.answer;
            // ä¿®æ­£ï¼šgetAllDecoyOptions ç¾åœ¨å·²åŒ…å«é€šç”¨æ–‡æ³•è©å½™ä½œç‚ºå¹²æ“¾é …
            let decoys = getAllDecoyOptions('g6_qa_match', correctAnswer);
            
            // éš¨æ©Ÿé¸å– 3 å€‹ä½œç‚ºå¹²æ“¾é¸é … (ç¸½å…± 4 å€‹é¸é …)
            decoys = decoys.slice(0, 3); 
            
            // Final options check:
            const options = shuffleArray([correctAnswer, ...decoys]); 
            // --- ç°¡åŒ–é‚è¼¯çµæŸ ---

            const optionsHtml = options.map(option => {
                const escapedOption = option.replace(/'/g, "\\'"); // ä¿®æ­£ï¼šè½‰ç¾©å–®å¼•è™Ÿ
                return `
                    <button onclick="handleAnswerG6('${escapedOption}')"
                        class="key-btn bg-secondary-blue hover:bg-blue-400 text-blue-900 font-bold py-3 rounded-xl text-lg shadow-cute text-left px-4">
                    ${formatDisplayWord(option, true)}
                </button>
            `;
            }).join('');

            container.innerHTML = `
                <section class="w-full bg-yellow-600 p-4 rounded-xl shadow-inner border-b-8 border-yellow-900">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">ğŸ—ºï¸ å•ç­”é¸æ“‡é¡Œå°‹å¯¶ (Q&A treasure hunt)</h2>
                    <p class="text-center text-sm text-yellow-200">ç›®æ¨™: é¸æ“‡æ­£ç¢ºçš„ç­”å¥ã€‚å°‹ç²å¯¶è—: ${state.g6_treasures} / åˆ†æ•¸: ${state.score}/${state.currentQuizSet.length}</p>
                </section>
                
                <div class="flex flex-col items-center p-6 bg-white rounded-xl shadow-md">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">ç¬¬ ${questionNumber} é¡Œ / å…± ${state.currentQuizSet.length} é¡Œ</h3>
                    
                    <div class="g6-question-box w-full max-w-3xl text-center mb-6">
                        <h4 class="text-3xl md:text-4xl font-extrabold text-yellow-900">Q: ${formatDisplayWord(currentQ.question, true)}</h4>
                    </div>

                    <h3 class="text-xl font-bold text-gray-800 mt-4 mb-4">è«‹é¸æ“‡æ­£ç¢ºçš„ç­”è¦†:</h3>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-3xl">
                        ${optionsHtml}
                    </div>
                    
                    <button onclick="initGame6()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8">é‡æ–°é–‹å§‹</button>
                </div>
            `;
        }
        // --- Game 6 End ---

        // --- Game 7: æ¯”è¼ƒç´šå‚³é€é–€ (âš–ï¸) ---
        
        // **ä¿®æ­£ï¼šæ™ºèƒ½ç²å–æ¯”è¼ƒç´šå½¢å¼å‡½æ•¸**
        function _getComparativeForm(baseAdj) {
            const adj = baseAdj.toUpperCase();
            
            // 1. ä¸è¦å‰‡å’Œå–®éŸ³ç¯€/çŸ­è©ç‰¹ä¾‹ (é«˜æº–ç¢ºåº¦åˆ—è¡¨)
            const specialComparatives = {
                // ä¸è¦å‰‡
                'GOOD': 'BETTER', 'BAD': 'WORSE', 'MUCH': 'MORE', 'MANY': 'MORE', 
                // å–®éŸ³ç¯€/çŸ­è© (åŒ…å«é›™å¯«è¦å‰‡ï¼Œä¿®æ­£äº† SMALL, FAST, SLOW ç­‰éŒ¯èª¤çš„ MORE)
                'BIG': 'BIGGER', 'SMALL': 'SMALLER', 'FAST': 'FASTER', 'SLOW': 'SLOWER',
                'HOT': 'HOTTER', 'THIN': 'THINNER', 'FAT': 'FATTER',
                'TALL': 'TALLER', 'SHORT': 'SHORTER', 'LONG': 'LONGER', 'NEW': 'NEWER',
                'OLD': 'OLDER', 'CLEAN': 'CLEANER', 'BRIGHT': 'BRIGHTER', 'DARK': 'DARKER',
                'WIDE': 'WIDER', 'LARGE': 'LARGER', 'SAFE': 'SAFER',
                // çµå°¾æ˜¯ Y (Y->IER)
                'HAPPY': 'HAPPIER', 'EASY': 'EASIER', 'PRETTY': 'PRETTIER', 'BUSY': 'BUSIER'
            };

            if (specialComparatives[adj]) {
                return specialComparatives[adj];
            }
            
            // 2. å¤šéŸ³ç¯€è¦å‰‡ (ä½¿ç”¨ MORE)
            // æª¢æŸ¥å·²çŸ¥é•·è©æˆ–å¸¸è¦‹å¤šéŸ³ç¯€å¾Œç¶´ (ä¾‹å¦‚ BEAUTIFUL, EXPENSIVE)
            if (['BEAUTIFUL', 'EXPENSIVE', 'IMPORTANT', 'DANGEROUS'].includes(adj) || 
                adj.length > 7 || 
                ['FUL', 'IVE', 'OUS', 'ING', 'ANT', 'ENT'].some(suffix => adj.endsWith(suffix))) 
            {
                return `MORE ${adj}`;
            }

            // 3. é è¨­è¦å‰‡ (å‰©ä¸‹çš„çŸ­è©å®‰å…¨åœ°åŠ  ERï¼Œé€™è£æ‡‰è©²æ¥µå°‘è§¸ç™¼)
            // Ends in E: Add R
            if (adj.endsWith('E')) {
                return adj + 'R';
            }

            // Default: Add ER (For unlisted 1-2 syllable words, e.g., RARE -> RARER, COLD -> COLDER)
            return adj + 'ER';
        }

        // è¼”åŠ©å‡½æ•¸ï¼šç”Ÿæˆæ¯”è¼ƒç´šé¸é …å’Œæ­£ç¢ºç­”æ¡ˆ (åŒ…å«åç¾©è©é‚è¼¯)
        function generateComparativeOptionsAndAnswer(currentQ, isAisB) {
            const baseAdj = currentQ.adj.toUpperCase();
            let effectiveAdj = baseAdj;

            // 1. åˆ¤æ–·æœ‰æ•ˆå½¢å®¹è©ï¼šå¦‚æœå• B vs A (isAisB=false)ï¼Œå‰‡ä½¿ç”¨åç¾©è©
            if (!isAisB) {
                effectiveAdj = ANTONYM_MAP[baseAdj] || baseAdj; 
            }

            const expectedAnswer = _getComparativeForm(effectiveAdj);

            // 2. æ”¶é›†æ‰€æœ‰å¯èƒ½çš„å¹²æ“¾é¸é … (å¾æ‰€æœ‰è©å½™åº«ä¸­æ‰¾)
            let allDecoys = new Set();
            
            // æ”¶é›†æ‰€æœ‰ç­”æ¡ˆä½œç‚ºå¹²æ“¾é …
            localData.g7_comparatives.forEach(q => {
                allDecoys.add(_getComparativeForm(q.adj.toUpperCase()));
                // ä¹ŸåŠ å…¥åç¾©è©çš„æ¯”è¼ƒç´šä½œç‚ºå¹²æ“¾
                const antonym = ANTONYM_MAP[q.adj.toUpperCase()];
                if(antonym) allDecoys.add(_getComparativeForm(antonym));
            });
            ALL_ADJECTIVES.forEach(adj => allDecoys.add(_getComparativeForm(adj)));
            // æ–°å¢ MORE + åŸç´šä½œç‚ºå¹²æ“¾é …ï¼Œä»¥åŠéŒ¯èª¤çš„ -ER å½¢å¼
            ALL_ADJECTIVES.forEach(adj => {
                 allDecoys.add(`MORE ${adj}`);
                 allDecoys.add(adj + 'ER'); // éŒ¯èª¤çš„ -ER å½¢å¼ï¼Œä¾‹å¦‚ MORE BEAUTIFUL çš„éŒ¯èª¤å¹²æ“¾ BEAUTIFULLER
            });

            // ç§»é™¤æ­£ç¢ºç­”æ¡ˆ
            allDecoys.delete(expectedAnswer);
            
            // é¸å– 3 å€‹å¹²æ“¾é …
            let incorrectOptions = shuffleArray(Array.from(allDecoys)).slice(0, 3);
            
            // Fallback and ensure 4 options
            while (incorrectOptions.length < 3) {
                const fallback = shuffleArray(ALL_ADJECTIVES).map(a => _getComparativeForm(a))[0];
                if (fallback !== expectedAnswer && !incorrectOptions.includes(fallback)) {
                    incorrectOptions.push(fallback);
                } else if (incorrectOptions.length < 3) {
                     // ç¢ºä¿è‡³å°‘æœ‰ä¸€ç¨®å½¢å¼éŒ¯èª¤ï¼Œä¾‹å¦‚åŸç´š
                     if(baseAdj !== expectedAnswer && !incorrectOptions.includes(baseAdj)) incorrectOptions.push(baseAdj);
                }
                incorrectOptions = Array.from(new Set(incorrectOptions)).filter(o => o.toUpperCase() !== expectedAnswer.toUpperCase()).slice(0, 3);
            }

            return {
                expectedAnswer: expectedAnswer,
                options: shuffleArray([expectedAnswer, ...incorrectOptions])
            };
        }

        function initGame7() {
            if (!setupQuiz('g7_comparatives', 'g7')) return;
            state.g7_inputAnswer = ''; // é‡ç½®è¼¸å…¥
            renderGame7();
        }
        
        function checkAnswerG7() {
            if (state.gameStatus !== 'playing') return;

            const currentQ = state.currentQuizSet[state.currentQIndex];
            const enteredText = state.g7_inputAnswer;
            
            const expectedAnswer = currentQ.answer;

            // ä¿®æ­£ï¼šç­”æ¡ˆæ¯”å°æ™‚ï¼Œåªæ¯”è¼ƒå…§å®¹ï¼Œå¿½ç•¥å¤§å°å¯«
            if (enteredText.trim().toUpperCase() === expectedAnswer.toUpperCase()) {
                
                if (!state.currentQHasFailed && !state.currentQHasScored) {
                    state.score++;
                    state.currentQHasScored = true;
                    MessageBox.show("ç­”å°äº†ï¼å¹³è¡¡å„€å™¨æ­£å¸¸é‹ä½œï¼âš–ï¸ (+1 åˆ†)", false);
                } else {
                    MessageBox.show("å·²ç­”å°ï¼Œè«‹é»æ“Šä¸‹ä¸€é¡Œã€‚âš–ï¸", false);
                }
                
                // é‡æ–°æ¸²æŸ“ (å¸¶æœ‰å¡«å…¥çš„ç­”æ¡ˆå’Œã€Œä¸‹ä¸€é¡Œã€æŒ‰éˆ•)
                renderGame7(true); 

            } else {
                // ç­”éŒ¯ï¼Œä¸è¨ˆåˆ†ï¼Œä¸è·³é¡Œ
                state.currentQHasFailed = true; // åªè¦éŒ¯ä¸€æ¬¡ï¼Œå°±ä¸èƒ½åŠ åˆ†
                MessageBox.show(`ç­”éŒ¯äº†ï¼Œè«‹å†è©¦è©¦ï¼`, true);
            }
        }


        function renderGame7(isAnswerFilled = false) {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'game7') return; 

            if (state.gameStatus === 'finished') {
                container.innerHTML = getFinishedScreen('âš–ï¸ æ¯”è¼ƒç´šå‚³é€é–€', state.score, state.currentQuizSet.length, initGame7);
                return;
            }
            
            const currentQ = state.currentQuizSet[state.currentQIndex];
            const questionNumber = state.currentQIndex + 1;
            
            const expectedAnswer = currentQ.answer;

            // æ±ºå®šå¥å­ä¸»èªå’Œå®¢é«”
            const subjectNoun = currentQ.nounA;
            const objectNoun = currentQ.nounB;
            const subjectURL = currentQ.urlA;
            const objectURL = currentQ.urlB;
            
            // æç¤ºè©ä½¿ç”¨å¾Œå°è¨­å®šçš„ hint
            const hintAdj = currentQ.hint;

            // æ±ºå®šå¡«ç©ºå…§å®¹
             const blankContent = isAnswerFilled 
                ? formatDisplayWord(expectedAnswer, false).toLowerCase() // å¡«å…¥ç­”æ¡ˆï¼Œå¼·åˆ¶å…¨å°å¯«
                : '____';

            const questionText = `${formatDisplayWord(subjectNoun, true)} is ${blankContent} than ${formatDisplayWord(objectNoun)}.`;


            container.innerHTML = `
                <section class="w-full bg-orange-500 p-4 rounded-xl shadow-inner border-b-8 border-orange-800 g7-header">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">âš–ï¸ æ¯”è¼ƒç´šå‚³é€é–€ (comparative quiz)</h2>
                    <p class="text-center text-sm text-orange-100">ç›®æ¨™: é¸æ“‡æ­£ç¢ºçš„æ¯”è¼ƒç´šå½¢å¼ã€‚åˆ†æ•¸: ${state.score}/${state.currentQuizSet.length}</p>
                </section>
                
                <div class="flex flex-col items-center p-6 bg-white rounded-xl shadow-md">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">ç¬¬ ${questionNumber} é¡Œ / å…± ${state.currentQuizSet.length} é¡Œ</h3>
                    
                    <div class="flex justify-center space-x-6 mb-6">
                        <div class="g7-image-box p-2">
                            <img src="${subjectURL}" alt="${subjectNoun}" class="w-24 h-24 object-contain" onerror="this.onerror=null; this.src='https://placehold.co/100x100/A0A0A0/FFFFFF?text=${subjectNoun.replace(/_/g, '+')}';">
                            <p class="mt-2 text-md font-bold text-gray-700">${formatDisplayWord(subjectNoun)}</p>
                        </div>
                        <div class="flex items-center justify-center text-5xl font-extrabold text-orange-700">VS</div>
                        <div class="g7-image-box p-2">
                            <img src="${objectURL}" alt="${objectNoun}" class="w-24 h-24 object-contain" onerror="this.onerror=null; this.src='https://placehold.co/100x100/A0A0A0/FFFFFF?text=${objectNoun.replace(/_/g, '+')}';">
                            <p class="mt-2 text-md font-bold text-gray-700">${formatDisplayWord(objectNoun)}</p>
                        </div>
                    </div>

                    <div class="p-4 bg-yellow-100 rounded-lg border-2 border-yellow-400 w-full max-w-xl text-center mb-6 g7-question-area">
                        <h4 class="text-2xl font-bold text-orange-700 mb-2">è«‹å¡«ç©º (æç¤ºè©: ${hintAdj})</h4>
                        <p class="text-xl font-medium text-gray-800">${questionText}</p>
                    </div>

                    <div class="flex flex-col items-center p-4 w-full max-w-lg">
                        <div class="flex w-full space-x-2">
                            <input type="text" 
                                   id="g7-input-answer"
                                   value="${isAnswerFilled ? formatDisplayWord(expectedAnswer, false).toLowerCase() : state.g7_inputAnswer}"
                                   oninput="state.g7_inputAnswer = this.value;"
                                   placeholder="è«‹è¼¸å…¥ç­”æ¡ˆ..." 
                                   class="flex-grow text-2xl p-3 border-4 border-secondary-blue rounded-xl text-center font-bold focus:border-blue-500 ${isAnswerFilled ? 'bg-green-100 text-green-700' : ''}"
                                   ${isAnswerFilled ? 'disabled' : ''}>
                            <button onclick="checkAnswerG7()" 
                                    class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-xl shadow-cute text-xl ${isAnswerFilled ? 'opacity-50 pointer-events-none' : ''}">
                                CHECK âœ…
                            </button>
                        </div>
                    </div>
                    
                    ${isAnswerFilled ? `<button onclick="goToNextQuestion(renderGame7)" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8">ä¸‹ä¸€é¡Œ</button>` : ''}
                    <button onclick="initGame7()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-2 px-6 rounded-full shadow-cute text-lg mt-8 ${isAnswerFilled ? 'hidden' : ''}">é‡æ–°é–‹å§‹</button>
                </div>
            `;

            // ç¢ºä¿è¼¸å…¥æ¡†åœ¨æ¸²æŸ“å¾Œèƒ½èšç„¦ (åƒ…åœ¨æœªå¡«å…¥ç­”æ¡ˆæ™‚)
            if (!isAnswerFilled) {
                setTimeout(() => {
                    document.getElementById('g7-input-answer')?.focus();
                }, 0);
            }
        }
        // --- Game 7 End ---
        
        // --- éŠæˆ²çµæŸç•«é¢æ¨¡æ¿ ---
        function getFinishedScreen(title, score, total, initFunc) {
            return `
                <section class="w-full bg-secondary-blue p-6 rounded-xl shadow-inner border-b-8 border-blue-600 text-center">
                    <h2 class="text-3xl md:text-5xl font-extrabold text-blue-900 mb-4">${title} ğŸ éŠæˆ²çµæŸ</h2>
                    <p class="text-2xl font-bold text-gray-800 mb-6">æ‚¨çš„æœ€çµ‚å¾—åˆ†æ˜¯: <span class="text-red-600">${score} / ${total}</span></p>
                    <button onclick="${initFunc.name}()" class="bg-primary-pink hover:bg-pink-400 text-white font-bold py-3 px-8 rounded-full shadow-cute text-xl">
                        å†ç©ä¸€æ¬¡
                    </button>
                </section>
            `;
        }

        // --- Admin Panel Functions ---
        const ADMIN_TABS = [
            { key: 'g1_words', name: 'ğŸ¦– è©å½™å°å°ç¢°', headers: ['word', 'emoji'] },
            { key: 'g2_words', name: 'ğŸ¤– æ‹¼è®€æ©Ÿå™¨äºº', headers: ['Word'] },
            { key: 'g3_words', name: 'ğŸ” å–®å­—å°‹å¯¶è¶£', headers: ['word'] }, // G3 Updated
            { key: 'g4_grammar', name: 'ğŸš— æ–‡æ³•åœè»Šå ´', headers: ['sentence', 'answer', 'hint'] },
            { key: 'g5_true_false', name: 'ğŸ¤¥ èª°èªªè¬Šäº†?', headers: ['statement', 'imageUrl', 'answer'] },
            { key: 'g6_qa_match', name: 'ğŸ—ºï¸ å°‹å¯¶å•ç­”', headers: ['question', 'answer'] }, 
            // ä¿®æ­£ G7 headers: æ›´æ–°ç‚ºæ–°æ ¼å¼
            { key: 'g7_comparatives', name: 'âš–ï¸ æ¯”è¼ƒç´šå‚³é€é–€', headers: ['nounA', 'nounB', 'answer', 'urlA', 'urlB', 'hint'] },
        ];
        let currentAdminKey = ADMIN_TABS[0].key;
        
        function getCurrentAdminTab() {
            return ADMIN_TABS.find(t => t.key === currentAdminKey);
        }

        function setCurrentAdminKey(key) {
            currentAdminKey = key;
            selectedWordIds.clear(); 
            editingItemId = null; // æ¸…ç©ºç·¨è¼¯ç‹€æ…‹
            renderWordAdmin();
        }
        
        // **æ–°å¢**ï¼šè¨­å®šç·¨è¼¯é …ç›® ID
        function editWordAdmin(id) {
            editingItemId = id;
            selectedWordIds.clear(); // ç·¨è¼¯æ™‚å–æ¶ˆæ‰€æœ‰é¸ä¸­
            renderWordAdmin();
        }

        // **æ–°å¢**ï¼šå„²å­˜ç·¨è¼¯å¾Œçš„é …ç›®
        function saveEditedWordAdmin(id) {
            const currentList = localData[currentAdminKey] || [];
            const currentTab = getCurrentAdminTab();
            // G2 è™•ç†æ–¹å¼ï¼šç›´æ¥ç”¨å­—ä¸²å€¼ä½œç‚º ID
            const index = currentAdminKey === 'g2_words' 
                ? currentList.findIndex(item => item === id)
                : currentList.findIndex(item => item.id === id);
            
            if (index === -1) return;

            // 1. è™•ç† G2 (ç°¡å–®å­—ä¸²)
            if (currentAdminKey === 'g2_words') {
                const newValue = document.getElementById(`edit-input-${id}`).value.trim();
                if (newValue) {
                    currentList[index] = newValue;
                }
            } 
            // 2. è™•ç†ç‰©ä»¶é™£åˆ—
            else {
                let updatedItem = { ...currentList[index] };
                let isValid = true;
                
                currentTab.headers.forEach(header => {
                    const inputElement = document.getElementById(`edit-input-${id}-${header}`);
                    if (inputElement) {
                         const newValue = inputElement.value.trim();
                         // å°æ–¼å¸ƒæ—å€¼ (G5 answer)ï¼Œç‰¹æ®Šè™•ç†
                         if (header === 'answer' && currentAdminKey === 'g5_true_false') {
                             updatedItem[header] = newValue.toLowerCase() === 'true';
                         } else {
                             updatedItem[header] = newValue;
                         }
                    }
                    // åªæœ‰ core fields éœ€è¦é©—è­‰ï¼Œhint, urlA, urlB å¯ä»¥ç‚ºç©º
                    if (header === 'answer' && !updatedItem[header]) { 
                         isValid = false; 
                    }
                });

                if (isValid) {
                    currentList[index] = updatedItem;
                } else {
                    MessageBox.show("å„²å­˜å¤±æ•—ï¼šè«‹ç¢ºä¿æ‰€æœ‰æ ¸å¿ƒæ¬„ä½éƒ½å·²å¡«å¯«ï¼", true);
                    return; 
                }
            }

            // 3. å®Œæˆå„²å­˜
            editingItemId = null; // é€€å‡ºç·¨è¼¯æ¨¡å¼
            saveWordsToLocal();
            MessageBox.show("å–®å­—å·²æˆåŠŸå„²å­˜ï¼", false);
            renderWordAdmin();
        }

        
        // è™•ç†å–®å€‹é …ç›®å‹¾é¸
        function handleSelectItemAdmin(id) {
            if (selectedWordIds.has(id)) {
                selectedWordIds.delete(id);
            } else {
                selectedWordIds.add(id);
            }
            renderWordAdmin();
        }
        
        // è™•ç†å…¨é¸/å–æ¶ˆå…¨é¸
        function handleSelectAllAdmin() {
            const currentList = localData[currentAdminKey] || [];
            // ç²å–ç•¶å‰é é¢æ‰€æœ‰é …ç›®çš„ ID/Value
            const allCurrentIds = currentList.map(item => currentAdminKey === 'g2_words' ? item : item.id);
            
            // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰é …ç›®éƒ½å·²é¸ä¸­
            const isAllSelected = currentList.length > 0 && 
                                  allCurrentIds.every(id => selectedWordIds.has(id));

            selectedWordIds.clear();

            if (!isAllSelected) {
                allCurrentIds.forEach(id => selectedWordIds.add(id));
            }

            renderWordAdmin();
        }
        
        // è™•ç†æ‰¹é‡åˆªé™¤
        function deleteSelectedWordsAdmin() {
            const currentList = localData[currentAdminKey] || [];
            const deletedCount = selectedWordIds.size;

            if (deletedCount === 0) {
                MessageBox.show("è«‹å…ˆå‹¾é¸è¦åˆªé™¤çš„è©å½™ï¼", true);
                return;
            }
            
            if (currentAdminKey === 'g2_words') {
                // Handle simple array (g2_words stores strings directly)
                localData[currentAdminKey] = currentList.filter(word => !selectedWordIds.has(word));
            } else {
                // Handle object array (all others store objects with 'id')
                localData[currentAdminKey] = currentList.filter(item => !selectedWordIds.has(item.id));
            }

            // æ¸…é™¤é¸ä¸­ç‹€æ…‹ä¸¦å„²å­˜
            selectedWordIds.clear();
            saveWordsToLocal();
            MessageBox.show(`æˆåŠŸåˆªé™¤ ${deletedCount} å€‹è©å½™ï¼`, false);
            renderWordAdmin();
        }

        // **æ–°å¢**ï¼šè‡ªå‹•ç”Ÿæˆæç¤ºè©çš„è¼”åŠ©å‡½æ•¸
        function getAutoHint(key, value) {
            // value å¿…é ˆæ˜¯å°å¯«é€²è¡ŒæŸ¥æ‰¾
            const lowerValue = value.toLowerCase().replace(/_/g, ' '); 
            
            if (key === 'answer') {
                return DEFAULT_HINTS[lowerValue] || ''; // æ‰¾ä¸åˆ°å‰‡ç•™ç©º
            }
            // For G7 'answer' which used to be 'adj' logic
            if (key === 'answer' && ALL_ADJECTIVES.includes(lowerValue)) {
                 const baseKey = lowerValue;
                 return DEFAULT_HINTS[baseKey] || ''; 
            }
            return '';
        }


        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                processFileData(content);
            };
            reader.readAsText(file);
        }

        function processFileData(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length === 0) { MessageBox.show("æ–‡ä»¶å…§å®¹ç‚ºç©ºæˆ–ç„¡æ³•è§£æã€‚", true); return; }

            const currentTab = getCurrentAdminTab();
            let addedCount = 0;
            let currentList = localData[currentAdminKey];

            lines.forEach(line => {
                const rawValues = line.split(',').map(v => v.trim());
                if (rawValues.length === 0) return;
                
                let newEntry = null;
                const newId = crypto.randomUUID();
                
                if (currentAdminKey === 'g2_words' && rawValues[0]) {
                     if (!currentList.includes(rawValues[0])) { newEntry = rawValues[0]; }
                } 
                else {
                    let tempEntry = { id: newId };
                    
                    if (currentAdminKey === 'g3_words' && rawValues.length >= 1) { // G3
                        tempEntry.verb = rawValues[0];
                        newEntry = tempEntry;
                    }
                    else if (currentAdminKey === 'g4_grammar' && rawValues.length >= 2) {
                        tempEntry.sentence = rawValues[0];
                        tempEntry.answer = rawValues[1];
                        // ä¿®æ­£ï¼šæª¢æŸ¥ hint æ˜¯å¦æä¾›ï¼Œå¦‚æœæ²’æœ‰å‰‡è‡ªå‹•ç”Ÿæˆ
                        tempEntry.hint = rawValues[2] || getAutoHint('answer', rawValues[1]);
                        newEntry = tempEntry;
                    } 
                    else if (currentAdminKey === 'g7_comparatives' && rawValues.length >= 3) {
                        // æ–°æ ¼å¼: nounA, nounB, answer, urlA, urlB, hint
                        tempEntry.nounA = rawValues[0];
                        tempEntry.nounB = rawValues[1];
                        tempEntry.answer = rawValues[2];
                        tempEntry.urlA = rawValues[3] || '';
                        tempEntry.urlB = rawValues[4] || '';
                        // ä¿®æ­£ï¼šæª¢æŸ¥ hint æ˜¯å¦æä¾›ï¼Œå¦‚æœæ²’æœ‰å‰‡è‡ªå‹•ç”Ÿæˆ
                        tempEntry.hint = rawValues[5] || getAutoHint('answer', rawValues[2]); 
                        newEntry = tempEntry;
                    } 
                    // Other fixed formats
                    else if (currentAdminKey === 'g1_words' && rawValues.length >= 2) { newEntry = { id: newId, word: rawValues[0], emoji: rawValues[1] }; }
                    else if (currentAdminKey === 'g3_actions' && rawValues.length >= 1) { newEntry = { id: newId, verb: rawValues[0] }; } 
                    else if (currentAdminKey === 'g5_true_false' && rawValues.length >= 3) { newEntry = { id: newId, statement: rawValues[0], imageUrl: rawValues[1], answer: rawValues[2].toLowerCase() === 'true' }; } 
                    else if (currentAdminKey === 'g6_qa_match' && rawValues.length >= 2) { newEntry = { id: newId, question: rawValues[0], answer: rawValues[1] }; }
                }

                if (newEntry && (currentAdminKey !== 'g4_grammar' && currentAdminKey !== 'g7_comparatives' || newEntry.answer)) {
                    if (currentAdminKey === 'g2_words') {
                        currentList.push(newEntry);
                    } else if (!currentList.some(item => JSON.stringify(item) === JSON.stringify(newEntry))) {
                        currentList.push(newEntry);
                    }
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                saveWordsToLocal(); 
                MessageBox.show(`æˆåŠŸå¾æ–‡ä»¶æ–°å¢ ${addedCount} å€‹è©å½™åˆ° ${currentTab.name}ï¼`, false);
                renderWordAdmin();
            } else {
                 MessageBox.show(`æ–‡ä»¶è§£æå®Œæˆï¼Œä½†æ²’æœ‰æ–°å¢ä»»ä½•æ–°çš„è©å½™ã€‚è«‹æª¢æŸ¥æ–‡ä»¶æ ¼å¼ã€‚`, true);
            }
            
            document.getElementById('file-upload-input').value = null;
        }

        function addWordAdmin() {
            const currentTab = getCurrentAdminTab();
            const inputElement = document.getElementById('admin-input-bulk');
            const inputContent = inputElement ? inputElement.value.trim() : '';
            
            if (!inputContent) { MessageBox.show("è«‹è¼¸å…¥è©å½™å…§å®¹ï¼", true); return; }

            const lines = inputContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let addedCount = 0;
            let currentList = localData[currentAdminKey];

            lines.forEach(line => {
                const rawValues = line.split(',').map(v => v.trim());
                if (rawValues.length === 0) return;
                
                let newEntry = null;
                const newId = crypto.randomUUID();

                if (currentAdminKey === 'g2_words' && rawValues[0]) {
                     if (!currentList.includes(rawValues[0])) newEntry = rawValues[0];
                } 
                else {
                    let tempEntry = { id: newId };
                    
                    if (currentAdminKey === 'g1_words' && rawValues.length >= 2) {
                        newEntry = { id: newId, word: rawValues[0], emoji: rawValues[1] };
                    } 
                    else if (currentAdminKey === 'g3_words' && rawValues.length >= 1) { // G3 Update
                         newEntry = { id: newId, verb: rawValues[0] };
                    }
                    else if (currentAdminKey === 'g3_actions' && rawValues.length >= 1) {
                        newEntry = { id: newId, verb: rawValues[0] };
                    }
                    // G4 æ•¸æ“šè§£æé‚è¼¯ï¼šåªéœ€è¦ sentence å’Œ answer
                    else if (currentAdminKey === 'g4_grammar' && rawValues.length >= 2) {
                        tempEntry.sentence = rawValues[0];
                        tempEntry.answer = rawValues[1];
                        // ä¿®æ­£ï¼šæª¢æŸ¥ hint æ˜¯å¦æä¾›ï¼Œå¦‚æœæ²’æœ‰å‰‡è‡ªå‹•ç”Ÿæˆ
                        tempEntry.hint = rawValues[2] || getAutoHint('answer', rawValues[1]);
                        newEntry = tempEntry;
                    } 
                    else if (currentAdminKey === 'g5_true_false' && rawValues.length >= 3) {
                        newEntry = { id: newId, statement: rawValues[0], imageUrl: rawValues[1], answer: rawValues[2].toLowerCase() === 'true' };
                    } 
                    else if (currentAdminKey === 'g6_qa_match' && rawValues.length >= 2) {
                        const answer = rawValues[1];
                        newEntry = { id: newId, question: rawValues[0], answer: answer };
                    }
                    else if (currentAdminKey === 'g7_comparatives' && rawValues.length >= 3) {
                        // æ–°æ ¼å¼: nounA, nounB, answer, urlA, urlB, hint
                        // æ³¨æ„: é€™è£¡çš„ answer å°±æ˜¯æ¯”è¼ƒç´šå–®å­—
                         const nounA = rawValues[0];
                         const nounB = rawValues[1];
                         const answer = rawValues[2];
                         const urlA = rawValues[3] || '';
                         const urlB = rawValues[4] || '';
                         const hint = rawValues[5] || getAutoHint('answer', answer);

                        newEntry = { id: newId, nounA: nounA, nounB: nounB, answer: answer, urlA: urlA, urlB: urlB, hint: hint };
                    }
                }
                
                if (newEntry) {
                    if (currentAdminKey === 'g2_words') {
                        currentList.push(newEntry);
                    } else if (!currentList.some(item => JSON.stringify(item) === JSON.stringify(newEntry))) {
                         currentList.push(newEntry);
                    } else {
                         return; 
                    }
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                saveWordsToLocal(); 
                MessageBox.show(`æˆåŠŸæ–°å¢ ${addedCount} å€‹è©å½™ï¼`, false);
                inputElement.value = ''; 
                renderWordAdmin();
            } else {
                 MessageBox.show("è«‹æª¢æŸ¥è¼¸å…¥å…§å®¹æ˜¯å¦ç‚ºæ–°è©å½™ä¸”æ ¼å¼æ­£ç¢ºã€‚", true);
            }
        }


        // å–®ç¨åˆªé™¤é …ç›®
        function deleteWordAdmin(id) {
            const currentTab = getCurrentAdminTab();
            const list = localData[currentAdminKey];

            if (currentAdminKey === 'g2_words') {
                // Simple String Array: Filter by value
                 localData[currentAdminKey] = list.filter(item => item !== id);
            } else {
                // Object Array: Filter by ID
                localData[currentAdminKey] = list.filter(item => item.id !== id);
            }
            
            // ç¢ºä¿é¸ä¸­ç‹€æ…‹åŒæ­¥æ¸…é™¤
            selectedWordIds.delete(id); 

            saveWordsToLocal(); 
            MessageBox.show("è©å½™å–®ç¨åˆªé™¤æˆåŠŸï¼", false);
            renderWordAdmin();
        }

        function renderWordAdmin() {
            const container = document.getElementById('game-content');
            if (!container || currentGame !== 'admin') return; 

            const currentList = localData[currentAdminKey] || [];
            const currentTab = getCurrentAdminTab();

            const inputPlaceholder = `è«‹ä½¿ç”¨é€—è™Ÿåˆ†éš”ï¼Œæ¯è¡Œä¸€ç­†è³‡æ–™ã€‚æ ¼å¼ï¼š${currentTab.headers.join(', ')}`;

            // --- Selection Logic Setup ---
            // ç²å–ç•¶å‰é é¢æ‰€æœ‰é …ç›®çš„ ID/Value
            const allCurrentIds = currentList.map(item => currentAdminKey === 'g2_words' ? item : item.id);
            // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰é …ç›®éƒ½å·²é¸ä¸­ (ä¸”åˆ—è¡¨ä¸ç‚ºç©º)
            const isAllSelected = currentList.length > 0 && 
                                  allCurrentIds.every(id => selectedWordIds.has(id));
            const selectedCount = allCurrentIds.filter(id => selectedWordIds.has(id)).length;


            // --- Header Controls ---
            const controlHeaderHtml = `
                <div class="flex justify-between items-center bg-gray-200 p-4 rounded-t-xl border-b border-gray-300">
                    <label class="flex items-center space-x-2 text-sm font-bold text-gray-700 cursor-pointer">
                        <input type="checkbox" 
                                class="form-checkbox h-5 w-5 text-blue-600 rounded cursor-pointer" 
                                onchange="handleSelectAllAdmin()"
                                ${isAllSelected ? 'checked' : ''}>
                        <span>å…¨é¸ (${selectedCount}/${currentList.length})</span>
                    </label>
                    <button onclick="deleteSelectedWordsAdmin()" 
                            class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full text-sm shadow-md transition duration-150"
                            ${selectedCount === 0 ? 'disabled' : ''}>
                        ğŸ—‘ï¸ åˆªé™¤é¸å®š (${selectedCount})
                    </button>
                </div>
            `;


            const listHtml = currentList.map((item, index) => {
                let display;
                let deleteId; // This ID is used for both deletion and selection

                if (currentAdminKey === 'g2_words') {
                    display = formatDisplayWord(item);
                    deleteId = item; // ID is the string value itself
                } else {
                    display = JSON.stringify(item);
                    deleteId = item.id; // ID is the object's unique ID
                    
                    if (currentAdminKey === 'g1_words') display = `${item.emoji} / ${formatDisplayWord(item.word)}`;
                    else if (currentAdminKey === 'g3_actions') display = `Verb: ${formatDisplayWord(item.verb)}`; 
                    else if (currentAdminKey === 'g3_words') display = `Word: ${formatDisplayWord(item.verb)}`; // G3 Update
                    else if (currentAdminKey === 'g4_grammar') display = `Sentence: ${formatDisplayWord(item.sentence)} / Answer: ${formatDisplayWord(item.answer)} / Hint: ${item.hint || 'N/A'}`;
                    else if (currentAdminKey === 'g5_true_false') display = `Statment: ${formatDisplayWord(item.statement)} / Ans: ${item.answer} / Img: ${item.imageUrl.substring(0, 10)}...`;
                    else if (currentAdminKey === 'g6_qa_match') display = `Q: ${formatDisplayWord(item.question)} / Ans: ${formatDisplayWord(item.answer)}`; 
                    else if (currentAdminKey === 'g7_comparatives') display = `${item.nounA} vs ${item.nounB} (Ans: ${item.answer}) / Hint: ${item.hint || 'N/A'}`;
                }
                
                const isChecked = selectedWordIds.has(deleteId);
                const isEditing = deleteId === editingItemId;

                // --- å…§è¯ç·¨è¼¯æ¨¡å¼ ---
                if (isEditing) {
                    let editInputs = '';
                    let itemToEdit = currentAdminKey === 'g2_words' ? item : currentList.find(i => i.id === deleteId);
                    
                    // G2 ç°¡å–®å­—ä¸²ç·¨è¼¯
                    if (currentAdminKey === 'g2_words') {
                        editInputs = `
                            <div class="w-full">
                                <label class="block text-xs font-bold mb-1">Word</label>
                                <input id="edit-input-${deleteId}" type="text" class="admin-input" value="${itemToEdit}">
                            </div>
                        `;
                    }
                    // ç‰©ä»¶é™£åˆ—ç·¨è¼¯
                    else {
                        editInputs = currentTab.headers.map(header => {
                            let value = itemToEdit[header] || '';
                            
                            // å°æ–¼å¸ƒæ—å€¼ (G5 answer)ï¼Œç‰¹æ®Šè™•ç†
                             if (header === 'answer' && currentAdminKey === 'g5_true_false') {
                                 value = itemToEdit[header] ? 'true' : 'false';
                             }

                            // åœ–ç‰‡ URL æ¬„ä½è¼ƒé•·ï¼Œçµ¦äºˆæ›´å¤šç©ºé–“
                            const inputType = header.includes('url') ? 'text' : 'text'; 
                            const label = header.charAt(0).toUpperCase() + header.slice(1);
                            
                            return `
                                <div class="w-1/2 md:w-1/3 p-1">
                                    <label class="block text-xs font-bold mb-1 text-gray-700">${label.replace(/_/g, ' ')}</label>
                                    <input id="edit-input-${deleteId}-${header}" type="${inputType}" class="admin-input" value="${value}" placeholder="${label}">
                                </div>
                            `;
                        }).join('');
                        editInputs = `<div class="flex flex-wrap -m-1 w-full">${editInputs}</div>`;
                    }
                    
                    return `
                        <li class="p-3 bg-yellow-100 rounded-lg shadow-xl mb-2 border-4 border-yellow-500 flex flex-col items-start space-y-2">
                            <h4 class="text-lg font-bold text-yellow-800">ç·¨è¼¯é …ç›® #${index + 1}</h4>
                            ${editInputs}
                            <div class="flex justify-end w-full space-x-2 mt-2">
                                <button onclick="saveEditedWordAdmin('${deleteId}')" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-full text-sm">
                                    å„²å­˜ âœ…
                                </button>
                                <button onclick="editingItemId=null; renderWordAdmin()" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded-full text-sm">
                                    å–æ¶ˆ
                                </button>
                            </div>
                        </li>
                    `;
                }

                // --- é¡¯ç¤ºæ¨¡å¼ ---
                return `
                    <li class="flex items-center p-3 bg-white rounded-lg shadow-sm mb-2 border-l-4 border-primary-pink transition duration-100 ${isChecked ? 'bg-blue-50 border-blue-400' : ''}">
                        <input type="checkbox" 
                                class="form-checkbox h-5 w-5 text-blue-600 rounded mr-3 flex-shrink-0 cursor-pointer" 
                                onchange="handleSelectItemAdmin('${deleteId}')"
                                ${isChecked ? 'checked' : ''}>
                        <span class="text-sm md:text-lg font-bold text-gray-800 break-all flex-grow">${index + 1}. ${display}</span>
                        
                        <div class="flex space-x-2 flex-shrink-0 ml-2">
                            <button onclick="editWordAdmin('${deleteId}')" class="text-blue-500 hover:text-blue-700 font-bold p-1 rounded-full bg-blue-100 transition duration-150 whitespace-nowrap text-sm">
                                ç·¨è¼¯ âœï¸
                            </button>
                            <button onclick="deleteWordAdmin('${deleteId}')" class="text-red-500 hover:text-red-700 font-bold p-1 rounded-full bg-red-100 transition duration-150 whitespace-nowrap text-sm">
                                å–®ç¨åˆªé™¤ ğŸ—‘ï¸
                            </button>
                        </div>
                    </li>
                `;
            }).join('');

            container.innerHTML = `
                <section class="w-full bg-primary-pink p-4 rounded-xl shadow-inner border-b-8 border-pink-600">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 text-center">âš™ï¸ å–®å­—/è¨­å®šç®¡ç†å¾Œå° (local storage admin panel)</h2>
                    <p class="text-center text-sm text-pink-100">ğŸ’¡ é€™è£¡çš„å–®å­—åƒ…å„²å­˜åœ¨æ‚¨ç•¶å‰çš„ç€è¦½å™¨ä¸­ã€‚</p>
                </section>
                
                <div class="flex flex-wrap justify-center space-x-1 mb-4">
                    ${ADMIN_TABS.map(tab => `
                        <button onclick="setCurrentAdminKey('${tab.key}')" class="tab-btn py-2 px-3 ${currentAdminKey === tab.key ? 'bg-secondary-blue text-blue-900 shadow-lg' : 'bg-gray-100 text-gray-700'}">
                            ${tab.name}
                        </button>
                    `).join('')}
                </div>
                
                <div class="file-upload-container mb-4 w-full p-4 bg-gray-100 rounded-xl shadow-md">
                    <label for="file-upload-input" class="text-sm font-semibold text-gray-700 mr-2 whitespace-nowrap">â¬†ï¸ åŒ¯å…¥æª”æ¡ˆ (.csv/.txt):</label>
                    <input type="file" id="file-upload-input" accept=".csv,.txt" class="file-upload-input" onchange="handleFileUpload(event)">
                    <p class="text-xs text-red-600 mt-2">**è«‹ç¢ºä¿æ–‡ä»¶æ ¼å¼ç¬¦åˆæ‰€é¸éŠæˆ²çš„é€—è™Ÿåˆ†éš”è¦æ±‚ã€‚**</p>
                </div>


                <div class="p-6 bg-keyboard-bg rounded-xl shadow-md w-full">
                    <label for="admin-input-bulk" class="block text-lg font-semibold text-gray-800 mb-2">æ–°å¢ ${currentTab.name} è©å½™ (æ‰¹é‡)</label>
                    <textarea id="admin-input-bulk" placeholder="${inputPlaceholder}" class="p-3 border-2 border-gray-300 rounded-lg focus:ring-secondary-blue focus:border-secondary-blue w-full resize-y h-32 mb-2"></textarea>
                    <button onclick="addWordAdmin()" 
                            class="bg-secondary-blue hover:bg-blue-400 text-blue-900 font-bold py-3 px-6 rounded-lg shadow-cute transition duration-150">
                        â• æ‰¹é‡æ–°å¢
                    </button>
                </div>

                <div class="p-6 bg-white rounded-xl shadow-md border-2 border-gray-200">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">${currentTab.name} åˆ—è¡¨ (${currentList.length} å€‹)</h3>
                    ${controlHeaderHtml}
                    <ul class="max-h-80 overflow-y-auto pt-4">
                        ${currentList.length > 0 ? listHtml : '<p class="text-gray-500 text-center py-4">ç›®å‰æ²’æœ‰è©å½™ã€‚è«‹æ–°å¢ï¼</p>'}
                    </ul>
                    <p class="text-xs text-gray-400 mt-4 text-center">æ‚¨çš„è¨­å®šå·²è‡ªå‹•å„²å­˜ã€‚</p>
                </div>
            `;
        }
        
        function initializeApp(retries = 0) {
            const container = document.getElementById('game-content');
            if (!container) {
                if (retries < 10) { 
                    setTimeout(() => initializeApp(retries + 1), 50);
                } else {
                    console.error("Critical Error: Failed to initialize app. The 'game-content' container never became available.");
                    document.body.innerHTML = '<div style="color: red; text-align: center; margin-top: 50px;">æ‡‰ç”¨ç¨‹å¼ç„¡æ³•å•Ÿå‹•ã€‚è«‹é‡æ–°è¼‰å…¥æˆ–æª¢æŸ¥ç€è¦½å™¨ç’°å¢ƒã€‚</div>';
                }
                return;
            }
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.add('bg-white', 'py-2', 'px-3', 'md:px-4', 'rounded-full', 'text-xs', 'md:text-sm', 'font-bold', 'text-gray-700', 'transition', 'duration-300', 'shadow-md', 'hover:bg-secondary-blue');
                
                const gameName = btn.getAttribute('data-game');
                if (gameName) {
                    btn.addEventListener('click', () => changeGame(gameName));
                }
            });

            setTabActive(currentGame);
            renderApp();
        }

        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
